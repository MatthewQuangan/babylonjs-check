{"version":3,"file":"static/js/853.1e028286.chunk.js","mappings":"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","sources":["../dev/core/src/Misc/HighDynamicRange/panoramaToCubemap.ts","../dev/core/src/Misc/HighDynamicRange/hdr.ts","../dev/core/src/Materials/Textures/Loaders/hdrTextureLoader.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/naming-convention */\r\nimport type { Nullable } from \"../../types\";\r\nimport { Vector3 } from \"../../Maths/math.vector\";\r\nimport { Constants } from \"../../Engines/constants\";\r\n\r\n/**\r\n * CubeMap information grouping all the data for each faces as well as the cubemap size.\r\n */\r\nexport interface CubeMapInfo {\r\n    /**\r\n     * The pixel array for the front face.\r\n     * This is stored in format, left to right, up to down format.\r\n     */\r\n    front: Nullable<ArrayBufferView>;\r\n\r\n    /**\r\n     * The pixel array for the back face.\r\n     * This is stored in format, left to right, up to down format.\r\n     */\r\n    back: Nullable<ArrayBufferView>;\r\n\r\n    /**\r\n     * The pixel array for the left face.\r\n     * This is stored in format, left to right, up to down format.\r\n     */\r\n    left: Nullable<ArrayBufferView>;\r\n\r\n    /**\r\n     * The pixel array for the right face.\r\n     * This is stored in format, left to right, up to down format.\r\n     */\r\n    right: Nullable<ArrayBufferView>;\r\n\r\n    /**\r\n     * The pixel array for the up face.\r\n     * This is stored in format, left to right, up to down format.\r\n     */\r\n    up: Nullable<ArrayBufferView>;\r\n\r\n    /**\r\n     * The pixel array for the down face.\r\n     * This is stored in format, left to right, up to down format.\r\n     */\r\n    down: Nullable<ArrayBufferView>;\r\n\r\n    /**\r\n     * The size of the cubemap stored.\r\n     *\r\n     * Each faces will be size * size pixels.\r\n     */\r\n    size: number;\r\n\r\n    /**\r\n     * The format of the texture.\r\n     *\r\n     * RGBA, RGB.\r\n     */\r\n    format: number;\r\n\r\n    /**\r\n     * The type of the texture data.\r\n     *\r\n     * UNSIGNED_INT, FLOAT.\r\n     */\r\n    type: number;\r\n\r\n    /**\r\n     * Specifies whether the texture is in gamma space.\r\n     */\r\n    gammaSpace: boolean;\r\n}\r\n\r\n/**\r\n * Helper class useful to convert panorama picture to their cubemap representation in 6 faces.\r\n */\r\nexport class PanoramaToCubeMapTools {\r\n    private static FACE_LEFT = [new Vector3(-1.0, -1.0, -1.0), new Vector3(1.0, -1.0, -1.0), new Vector3(-1.0, 1.0, -1.0), new Vector3(1.0, 1.0, -1.0)];\r\n    private static FACE_RIGHT = [new Vector3(1.0, -1.0, 1.0), new Vector3(-1.0, -1.0, 1.0), new Vector3(1.0, 1.0, 1.0), new Vector3(-1.0, 1.0, 1.0)];\r\n    private static FACE_FRONT = [new Vector3(1.0, -1.0, -1.0), new Vector3(1.0, -1.0, 1.0), new Vector3(1.0, 1.0, -1.0), new Vector3(1.0, 1.0, 1.0)];\r\n    private static FACE_BACK = [new Vector3(-1.0, -1.0, 1.0), new Vector3(-1.0, -1.0, -1.0), new Vector3(-1.0, 1.0, 1.0), new Vector3(-1.0, 1.0, -1.0)];\r\n    private static FACE_DOWN = [new Vector3(1.0, 1.0, -1.0), new Vector3(1.0, 1.0, 1.0), new Vector3(-1.0, 1.0, -1.0), new Vector3(-1.0, 1.0, 1.0)];\r\n    private static FACE_UP = [new Vector3(-1.0, -1.0, -1.0), new Vector3(-1.0, -1.0, 1.0), new Vector3(1.0, -1.0, -1.0), new Vector3(1.0, -1.0, 1.0)];\r\n\r\n    /**\r\n     * Converts a panorama stored in RGB right to left up to down format into a cubemap (6 faces).\r\n     *\r\n     * @param float32Array The source data.\r\n     * @param inputWidth The width of the input panorama.\r\n     * @param inputHeight The height of the input panorama.\r\n     * @param size The willing size of the generated cubemap (each faces will be size * size pixels)\r\n     * @param supersample enable supersampling the cubemap\r\n     * @returns The cubemap data\r\n     */\r\n    public static ConvertPanoramaToCubemap(float32Array: Float32Array, inputWidth: number, inputHeight: number, size: number, supersample = false): CubeMapInfo {\r\n        if (!float32Array) {\r\n            // eslint-disable-next-line no-throw-literal\r\n            throw \"ConvertPanoramaToCubemap: input cannot be null\";\r\n        }\r\n\r\n        if (float32Array.length != inputWidth * inputHeight * 3) {\r\n            // eslint-disable-next-line no-throw-literal\r\n            throw \"ConvertPanoramaToCubemap: input size is wrong\";\r\n        }\r\n\r\n        const textureFront = this.CreateCubemapTexture(size, this.FACE_FRONT, float32Array, inputWidth, inputHeight, supersample);\r\n        const textureBack = this.CreateCubemapTexture(size, this.FACE_BACK, float32Array, inputWidth, inputHeight, supersample);\r\n        const textureLeft = this.CreateCubemapTexture(size, this.FACE_LEFT, float32Array, inputWidth, inputHeight, supersample);\r\n        const textureRight = this.CreateCubemapTexture(size, this.FACE_RIGHT, float32Array, inputWidth, inputHeight, supersample);\r\n        const textureUp = this.CreateCubemapTexture(size, this.FACE_UP, float32Array, inputWidth, inputHeight, supersample);\r\n        const textureDown = this.CreateCubemapTexture(size, this.FACE_DOWN, float32Array, inputWidth, inputHeight, supersample);\r\n\r\n        return {\r\n            front: textureFront,\r\n            back: textureBack,\r\n            left: textureLeft,\r\n            right: textureRight,\r\n            up: textureUp,\r\n            down: textureDown,\r\n            size: size,\r\n            type: Constants.TEXTURETYPE_FLOAT,\r\n            format: Constants.TEXTUREFORMAT_RGB,\r\n            gammaSpace: false,\r\n        };\r\n    }\r\n\r\n    private static CreateCubemapTexture(texSize: number, faceData: Vector3[], float32Array: Float32Array, inputWidth: number, inputHeight: number, supersample = false) {\r\n        const buffer = new ArrayBuffer(texSize * texSize * 4 * 3);\r\n        const textureArray = new Float32Array(buffer);\r\n\r\n        // If supersampling, determine number of samples needed when source texture width is divided for 4 cube faces\r\n        const samples = supersample ? Math.max(1, Math.round(inputWidth / 4 / texSize)) : 1;\r\n        const sampleFactor = 1 / samples;\r\n        const sampleFactorSqr = sampleFactor * sampleFactor;\r\n\r\n        const rotDX1 = faceData[1].subtract(faceData[0]).scale(sampleFactor / texSize);\r\n        const rotDX2 = faceData[3].subtract(faceData[2]).scale(sampleFactor / texSize);\r\n\r\n        const dy = 1 / texSize;\r\n        let fy = 0;\r\n\r\n        for (let y = 0; y < texSize; y++) {\r\n            for (let sy = 0; sy < samples; sy++) {\r\n                let xv1 = faceData[0];\r\n                let xv2 = faceData[2];\r\n\r\n                for (let x = 0; x < texSize; x++) {\r\n                    for (let sx = 0; sx < samples; sx++) {\r\n                        const v = xv2.subtract(xv1).scale(fy).add(xv1);\r\n                        v.normalize();\r\n\r\n                        const color = this.CalcProjectionSpherical(v, float32Array, inputWidth, inputHeight);\r\n\r\n                        // 3 channels per pixels\r\n                        textureArray[y * texSize * 3 + x * 3 + 0] += color.r * sampleFactorSqr;\r\n                        textureArray[y * texSize * 3 + x * 3 + 1] += color.g * sampleFactorSqr;\r\n                        textureArray[y * texSize * 3 + x * 3 + 2] += color.b * sampleFactorSqr;\r\n\r\n                        xv1 = xv1.add(rotDX1);\r\n                        xv2 = xv2.add(rotDX2);\r\n                    }\r\n                }\r\n\r\n                fy += dy * sampleFactor;\r\n            }\r\n        }\r\n\r\n        return textureArray;\r\n    }\r\n\r\n    private static CalcProjectionSpherical(vDir: Vector3, float32Array: Float32Array, inputWidth: number, inputHeight: number): any {\r\n        let theta = Math.atan2(vDir.z, vDir.x);\r\n        const phi = Math.acos(vDir.y);\r\n\r\n        while (theta < -Math.PI) {\r\n            theta += 2 * Math.PI;\r\n        }\r\n        while (theta > Math.PI) {\r\n            theta -= 2 * Math.PI;\r\n        }\r\n\r\n        let dx = theta / Math.PI;\r\n        const dy = phi / Math.PI;\r\n\r\n        // recenter.\r\n        dx = dx * 0.5 + 0.5;\r\n\r\n        let px = Math.round(dx * inputWidth);\r\n        if (px < 0) {\r\n            px = 0;\r\n        } else if (px >= inputWidth) {\r\n            px = inputWidth - 1;\r\n        }\r\n\r\n        let py = Math.round(dy * inputHeight);\r\n        if (py < 0) {\r\n            py = 0;\r\n        } else if (py >= inputHeight) {\r\n            py = inputHeight - 1;\r\n        }\r\n\r\n        const inputY = inputHeight - py - 1;\r\n        const r = float32Array[inputY * inputWidth * 3 + px * 3 + 0];\r\n        const g = float32Array[inputY * inputWidth * 3 + px * 3 + 1];\r\n        const b = float32Array[inputY * inputWidth * 3 + px * 3 + 2];\r\n\r\n        return {\r\n            r: r,\r\n            g: g,\r\n            b: b,\r\n        };\r\n    }\r\n}\r\n","import type { CubeMapInfo } from \"./panoramaToCubemap\";\r\nimport { PanoramaToCubeMapTools } from \"./panoramaToCubemap\";\r\n\r\n/**\r\n * Header information of HDR texture files.\r\n */\r\nexport interface HDRInfo {\r\n    /**\r\n     * The height of the texture in pixels.\r\n     */\r\n    height: number;\r\n\r\n    /**\r\n     * The width of the texture in pixels.\r\n     */\r\n    width: number;\r\n\r\n    /**\r\n     * The index of the beginning of the data in the binary file.\r\n     */\r\n    dataPosition: number;\r\n}\r\n\r\n/* This groups tools to convert HDR texture to native colors array. */\r\n\r\nfunction ldexp(mantissa: number, exponent: number): number {\r\n    if (exponent > 1023) {\r\n        return mantissa * Math.pow(2, 1023) * Math.pow(2, exponent - 1023);\r\n    }\r\n\r\n    if (exponent < -1074) {\r\n        return mantissa * Math.pow(2, -1074) * Math.pow(2, exponent + 1074);\r\n    }\r\n\r\n    return mantissa * Math.pow(2, exponent);\r\n}\r\n\r\nfunction rgbe2float(float32array: Float32Array, red: number, green: number, blue: number, exponent: number, index: number) {\r\n    if (exponent > 0) {\r\n        /*nonzero pixel*/\r\n        exponent = ldexp(1.0, exponent - (128 + 8));\r\n\r\n        float32array[index + 0] = red * exponent;\r\n        float32array[index + 1] = green * exponent;\r\n        float32array[index + 2] = blue * exponent;\r\n    } else {\r\n        float32array[index + 0] = 0;\r\n        float32array[index + 1] = 0;\r\n        float32array[index + 2] = 0;\r\n    }\r\n}\r\n\r\nfunction readStringLine(uint8array: Uint8Array, startIndex: number): string {\r\n    let line = \"\";\r\n    let character = \"\";\r\n\r\n    for (let i = startIndex; i < uint8array.length - startIndex; i++) {\r\n        character = String.fromCharCode(uint8array[i]);\r\n\r\n        if (character == \"\\n\") {\r\n            break;\r\n        }\r\n\r\n        line += character;\r\n    }\r\n\r\n    return line;\r\n}\r\n\r\n/**\r\n * Reads header information from an RGBE texture stored in a native array.\r\n * More information on this format are available here:\r\n * https://en.wikipedia.org/wiki/RGBE_image_format\r\n *\r\n * @param uint8array The binary file stored in  native array.\r\n * @returns The header information.\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport function RGBE_ReadHeader(uint8array: Uint8Array): HDRInfo {\r\n    let height: number = 0;\r\n    let width: number = 0;\r\n\r\n    let line = readStringLine(uint8array, 0);\r\n    if (line[0] != \"#\" || line[1] != \"?\") {\r\n        // eslint-disable-next-line no-throw-literal\r\n        throw \"Bad HDR Format.\";\r\n    }\r\n\r\n    let endOfHeader = false;\r\n    let findFormat = false;\r\n    let lineIndex: number = 0;\r\n\r\n    do {\r\n        lineIndex += line.length + 1;\r\n        line = readStringLine(uint8array, lineIndex);\r\n\r\n        if (line == \"FORMAT=32-bit_rle_rgbe\") {\r\n            findFormat = true;\r\n        } else if (line.length == 0) {\r\n            endOfHeader = true;\r\n        }\r\n    } while (!endOfHeader);\r\n\r\n    if (!findFormat) {\r\n        // eslint-disable-next-line no-throw-literal\r\n        throw \"HDR Bad header format, unsupported FORMAT\";\r\n    }\r\n\r\n    lineIndex += line.length + 1;\r\n    line = readStringLine(uint8array, lineIndex);\r\n\r\n    const sizeRegexp = /^-Y (.*) \\+X (.*)$/g;\r\n    const match = sizeRegexp.exec(line);\r\n\r\n    // TODO. Support +Y and -X if needed.\r\n    if (!match || match.length < 3) {\r\n        // eslint-disable-next-line no-throw-literal\r\n        throw \"HDR Bad header format, no size\";\r\n    }\r\n    width = parseInt(match[2]);\r\n    height = parseInt(match[1]);\r\n\r\n    if (width < 8 || width > 0x7fff) {\r\n        // eslint-disable-next-line no-throw-literal\r\n        throw \"HDR Bad header format, unsupported size\";\r\n    }\r\n\r\n    lineIndex += line.length + 1;\r\n\r\n    return {\r\n        height: height,\r\n        width: width,\r\n        dataPosition: lineIndex,\r\n    };\r\n}\r\n\r\n/**\r\n * Returns the cubemap information (each faces texture data) extracted from an RGBE texture.\r\n * This RGBE texture needs to store the information as a panorama.\r\n *\r\n * More information on this format are available here:\r\n * https://en.wikipedia.org/wiki/RGBE_image_format\r\n *\r\n * @param buffer The binary file stored in an array buffer.\r\n * @param size The expected size of the extracted cubemap.\r\n * @param supersample enable supersampling the cubemap (default: false)\r\n * @returns The Cube Map information.\r\n */\r\nexport function GetCubeMapTextureData(buffer: ArrayBuffer, size: number, supersample = false): CubeMapInfo {\r\n    const uint8array = new Uint8Array(buffer);\r\n    const hdrInfo = RGBE_ReadHeader(uint8array);\r\n    const data = RGBE_ReadPixels(uint8array, hdrInfo);\r\n\r\n    const cubeMapData = PanoramaToCubeMapTools.ConvertPanoramaToCubemap(data, hdrInfo.width, hdrInfo.height, size, supersample);\r\n\r\n    return cubeMapData;\r\n}\r\n\r\n/**\r\n * Returns the pixels data extracted from an RGBE texture.\r\n * This pixels will be stored left to right up to down in the R G B order in one array.\r\n *\r\n * More information on this format are available here:\r\n * https://en.wikipedia.org/wiki/RGBE_image_format\r\n *\r\n * @param uint8array The binary file stored in an array buffer.\r\n * @param hdrInfo The header information of the file.\r\n * @returns The pixels data in RGB right to left up to down order.\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport function RGBE_ReadPixels(uint8array: Uint8Array, hdrInfo: HDRInfo): Float32Array {\r\n    return readRGBEPixelsRLE(uint8array, hdrInfo);\r\n}\r\n\r\nfunction readRGBEPixelsRLE(uint8array: Uint8Array, hdrInfo: HDRInfo): Float32Array {\r\n    let num_scanlines = hdrInfo.height;\r\n    const scanline_width = hdrInfo.width;\r\n\r\n    let a: number, b: number, c: number, d: number, count: number;\r\n    let dataIndex = hdrInfo.dataPosition;\r\n    let index = 0,\r\n        endIndex = 0,\r\n        i = 0;\r\n\r\n    const scanLineArrayBuffer = new ArrayBuffer(scanline_width * 4); // four channel R G B E\r\n    const scanLineArray = new Uint8Array(scanLineArrayBuffer);\r\n\r\n    // 3 channels of 4 bytes per pixel in float.\r\n    const resultBuffer = new ArrayBuffer(hdrInfo.width * hdrInfo.height * 4 * 3);\r\n    const resultArray = new Float32Array(resultBuffer);\r\n\r\n    // read in each successive scanline\r\n    while (num_scanlines > 0) {\r\n        a = uint8array[dataIndex++];\r\n        b = uint8array[dataIndex++];\r\n        c = uint8array[dataIndex++];\r\n        d = uint8array[dataIndex++];\r\n\r\n        if (a != 2 || b != 2 || c & 0x80 || hdrInfo.width < 8 || hdrInfo.width > 32767) {\r\n            return readRGBEPixelsNotRLE(uint8array, hdrInfo);\r\n        }\r\n\r\n        if (((c << 8) | d) != scanline_width) {\r\n            // eslint-disable-next-line no-throw-literal\r\n            throw \"HDR Bad header format, wrong scan line width\";\r\n        }\r\n\r\n        index = 0;\r\n\r\n        // read each of the four channels for the scanline into the buffer\r\n        for (i = 0; i < 4; i++) {\r\n            endIndex = (i + 1) * scanline_width;\r\n\r\n            while (index < endIndex) {\r\n                a = uint8array[dataIndex++];\r\n                b = uint8array[dataIndex++];\r\n\r\n                if (a > 128) {\r\n                    // a run of the same value\r\n                    count = a - 128;\r\n                    if (count == 0 || count > endIndex - index) {\r\n                        // eslint-disable-next-line no-throw-literal\r\n                        throw \"HDR Bad Format, bad scanline data (run)\";\r\n                    }\r\n\r\n                    while (count-- > 0) {\r\n                        scanLineArray[index++] = b;\r\n                    }\r\n                } else {\r\n                    // a non-run\r\n                    count = a;\r\n                    if (count == 0 || count > endIndex - index) {\r\n                        // eslint-disable-next-line no-throw-literal\r\n                        throw \"HDR Bad Format, bad scanline data (non-run)\";\r\n                    }\r\n\r\n                    scanLineArray[index++] = b;\r\n                    if (--count > 0) {\r\n                        for (let j = 0; j < count; j++) {\r\n                            scanLineArray[index++] = uint8array[dataIndex++];\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        // now convert data from buffer into floats\r\n        for (i = 0; i < scanline_width; i++) {\r\n            a = scanLineArray[i];\r\n            b = scanLineArray[i + scanline_width];\r\n            c = scanLineArray[i + 2 * scanline_width];\r\n            d = scanLineArray[i + 3 * scanline_width];\r\n\r\n            rgbe2float(resultArray, a, b, c, d, (hdrInfo.height - num_scanlines) * scanline_width * 3 + i * 3);\r\n        }\r\n\r\n        num_scanlines--;\r\n    }\r\n\r\n    return resultArray;\r\n}\r\n\r\nfunction readRGBEPixelsNotRLE(uint8array: Uint8Array, hdrInfo: HDRInfo): Float32Array {\r\n    // this file is not run length encoded\r\n    // read values sequentially\r\n\r\n    let num_scanlines = hdrInfo.height;\r\n    const scanline_width = hdrInfo.width;\r\n\r\n    let a: number, b: number, c: number, d: number, i: number;\r\n    let dataIndex = hdrInfo.dataPosition;\r\n\r\n    // 3 channels of 4 bytes per pixel in float.\r\n    const resultBuffer = new ArrayBuffer(hdrInfo.width * hdrInfo.height * 4 * 3);\r\n    const resultArray = new Float32Array(resultBuffer);\r\n\r\n    // read in each successive scanline\r\n    while (num_scanlines > 0) {\r\n        for (i = 0; i < hdrInfo.width; i++) {\r\n            a = uint8array[dataIndex++];\r\n            b = uint8array[dataIndex++];\r\n            c = uint8array[dataIndex++];\r\n            d = uint8array[dataIndex++];\r\n\r\n            rgbe2float(resultArray, a, b, c, d, (hdrInfo.height - num_scanlines) * scanline_width * 3 + i * 3);\r\n        }\r\n\r\n        num_scanlines--;\r\n    }\r\n\r\n    return resultArray;\r\n}\r\n\r\n/**\r\n * @deprecated Use functions separately\r\n */\r\nexport const HDRTools = {\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    RGBE_ReadHeader,\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    GetCubeMapTextureData,\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    RGBE_ReadPixels,\r\n};\r\n","import { RGBE_ReadHeader, RGBE_ReadPixels } from \"../../../Misc/HighDynamicRange/hdr\";\r\nimport type { InternalTexture } from \"../../../Materials/Textures/internalTexture\";\r\nimport type { IInternalTextureLoader } from \"./internalTextureLoader\";\r\nimport { Constants } from \"../../../Engines/constants\";\r\n\r\n/**\r\n * Implementation of the HDR Texture Loader.\r\n * @internal\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport class _HDRTextureLoader implements IInternalTextureLoader {\r\n    /**\r\n     * Defines whether the loader supports cascade loading the different faces.\r\n     */\r\n    public readonly supportCascades = false;\r\n\r\n    /**\r\n     * Uploads the cube texture data to the WebGL texture. It has already been bound.\r\n     */\r\n    public loadCubeData(): void {\r\n        // eslint-disable-next-line no-throw-literal\r\n        throw \".env not supported in Cube.\";\r\n    }\r\n\r\n    /**\r\n     * Uploads the 2D texture data to the WebGL texture. It has already been bound once in the callback.\r\n     * @param data contains the texture data\r\n     * @param texture defines the BabylonJS internal texture\r\n     * @param callback defines the method to call once ready to upload\r\n     */\r\n    public loadData(\r\n        data: ArrayBufferView,\r\n        texture: InternalTexture,\r\n        callback: (width: number, height: number, loadMipmap: boolean, isCompressed: boolean, done: () => void) => void\r\n    ): void {\r\n        const uint8array = new Uint8Array(data.buffer, data.byteOffset, data.byteLength);\r\n        const hdrInfo = RGBE_ReadHeader(uint8array);\r\n        const pixelsDataRGB32 = RGBE_ReadPixels(uint8array, hdrInfo);\r\n\r\n        const pixels = hdrInfo.width * hdrInfo.height;\r\n        const pixelsDataRGBA32 = new Float32Array(pixels * 4);\r\n        for (let i = 0; i < pixels; i += 1) {\r\n            pixelsDataRGBA32[i * 4] = pixelsDataRGB32[i * 3];\r\n            pixelsDataRGBA32[i * 4 + 1] = pixelsDataRGB32[i * 3 + 1];\r\n            pixelsDataRGBA32[i * 4 + 2] = pixelsDataRGB32[i * 3 + 2];\r\n            pixelsDataRGBA32[i * 4 + 3] = 1;\r\n        }\r\n\r\n        callback(hdrInfo.width, hdrInfo.height, texture.generateMipMaps, false, () => {\r\n            const engine = texture.getEngine();\r\n            texture.type = Constants.TEXTURETYPE_FLOAT;\r\n            texture.format = Constants.TEXTUREFORMAT_RGBA;\r\n            texture._gammaSpace = false;\r\n            engine._uploadDataToTextureDirectly(texture, pixelsDataRGBA32);\r\n        });\r\n    }\r\n}\r\n"],"names":["PanoramaToCubeMapTools","ConvertPanoramaToCubemap","float32Array","inputWidth","inputHeight","size","supersample","arguments","length","undefined","front","this","CreateCubemapTexture","FACE_FRONT","back","FACE_BACK","left","FACE_LEFT","right","FACE_RIGHT","up","FACE_UP","down","FACE_DOWN","type","format","gammaSpace","texSize","faceData","buffer","ArrayBuffer","textureArray","Float32Array","samples","Math","max","round","sampleFactor","sampleFactorSqr","rotDX1","subtract","scale","rotDX2","dy","fy","y","sy","xv1","xv2","x","sx","v","add","normalize","color","CalcProjectionSpherical","r","g","b","vDir","theta","atan2","z","phi","acos","PI","dx","px","py","inputY","rgbe2float","float32array","red","green","blue","exponent","index","mantissa","pow","ldexp","readStringLine","uint8array","startIndex","line","character","i","String","fromCharCode","RGBE_ReadHeader","height","width","endOfHeader","findFormat","lineIndex","match","exec","parseInt","dataPosition","RGBE_ReadPixels","hdrInfo","num_scanlines","scanline_width","a","c","d","count","dataIndex","endIndex","scanLineArrayBuffer","scanLineArray","Uint8Array","resultBuffer","resultArray","readRGBEPixelsNotRLE","j","readRGBEPixelsRLE","Vector3","_HDRTextureLoader","constructor","supportCascades","loadCubeData","loadData","data","texture","callback","byteOffset","byteLength","pixelsDataRGB32","pixels","pixelsDataRGBA32","generateMipMaps","engine","getEngine","_gammaSpace","_uploadDataToTextureDirectly"],"sourceRoot":""}