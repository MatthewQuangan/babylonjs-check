{"version":3,"file":"static/js/140.9c4d033c.chunk.js","mappings":"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","sources":["../dev/core/src/Misc/basis.ts","../dev/core/src/Misc/basisWorker.ts","../dev/core/src/Materials/Textures/Loaders/basisTextureLoader.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/naming-convention */\r\nimport type { Nullable } from \"../types\";\r\nimport { Tools } from \"./tools\";\r\nimport { Texture } from \"../Materials/Textures/texture\";\r\nimport { InternalTexture, InternalTextureSource } from \"../Materials/Textures/internalTexture\";\r\nimport { Scalar } from \"../Maths/math.scalar\";\r\nimport { Constants } from \"../Engines/constants\";\r\nimport type { Engine } from \"../Engines/engine\";\r\nimport { initializeWebWorker, workerFunction } from \"./basisWorker\";\r\n\r\n/**\r\n * Info about the .basis files\r\n */\r\nexport class BasisFileInfo {\r\n    /**\r\n     * If the file has alpha\r\n     */\r\n    public hasAlpha: boolean;\r\n    /**\r\n     * Info about each image of the basis file\r\n     */\r\n    public images: Array<{ levels: Array<{ width: number; height: number; transcodedPixels: ArrayBufferView }> }>;\r\n}\r\n\r\n/**\r\n * Result of transcoding a basis file\r\n */\r\nclass TranscodeResult {\r\n    /**\r\n     * Info about the .basis file\r\n     */\r\n    public fileInfo: BasisFileInfo;\r\n    /**\r\n     * Format to use when loading the file\r\n     */\r\n    public format: number;\r\n}\r\n\r\n/**\r\n * Configuration options for the Basis transcoder\r\n */\r\nexport class BasisTranscodeConfiguration {\r\n    /**\r\n     * Supported compression formats used to determine the supported output format of the transcoder\r\n     */\r\n    supportedCompressionFormats?: {\r\n        /**\r\n         * etc1 compression format\r\n         */\r\n        etc1?: boolean;\r\n        /**\r\n         * s3tc compression format\r\n         */\r\n        s3tc?: boolean;\r\n        /**\r\n         * pvrtc compression format\r\n         */\r\n        pvrtc?: boolean;\r\n        /**\r\n         * etc2 compression format\r\n         */\r\n        etc2?: boolean;\r\n        /**\r\n         * astc compression format\r\n         */\r\n        astc?: boolean;\r\n        /**\r\n         * bc7 compression format\r\n         */\r\n        bc7?: boolean;\r\n    };\r\n    /**\r\n     * If mipmap levels should be loaded for transcoded images (Default: true)\r\n     */\r\n    loadMipmapLevels?: boolean;\r\n    /**\r\n     * Index of a single image to load (Default: all images)\r\n     */\r\n    loadSingleImage?: number;\r\n}\r\n\r\n/**\r\n * @internal\r\n * Enum of basis transcoder formats\r\n */\r\nenum BASIS_FORMATS {\r\n    cTFETC1 = 0,\r\n    cTFETC2 = 1,\r\n    cTFBC1 = 2,\r\n    cTFBC3 = 3,\r\n    cTFBC4 = 4,\r\n    cTFBC5 = 5,\r\n    cTFBC7 = 6,\r\n    cTFPVRTC1_4_RGB = 8,\r\n    cTFPVRTC1_4_RGBA = 9,\r\n    cTFASTC_4x4 = 10,\r\n    cTFATC_RGB = 11,\r\n    cTFATC_RGBA_INTERPOLATED_ALPHA = 12,\r\n    cTFRGBA32 = 13,\r\n    cTFRGB565 = 14,\r\n    cTFBGR565 = 15,\r\n    cTFRGBA4444 = 16,\r\n    cTFFXT1_RGB = 17,\r\n    cTFPVRTC2_4_RGB = 18,\r\n    cTFPVRTC2_4_RGBA = 19,\r\n    cTFETC2_EAC_R11 = 20,\r\n    cTFETC2_EAC_RG11 = 21,\r\n}\r\n\r\n/**\r\n * Used to load .Basis files\r\n * See https://github.com/BinomialLLC/basis_universal/tree/master/webgl\r\n */\r\nexport const BasisToolsOptions = {\r\n    /**\r\n     * URL to use when loading the basis transcoder\r\n     */\r\n    JSModuleURL: `${Tools._DefaultCdnUrl}/basisTranscoder/1/basis_transcoder.js`,\r\n    /**\r\n     * URL to use when loading the wasm module for the transcoder\r\n     */\r\n    WasmModuleURL: `${Tools._DefaultCdnUrl}/basisTranscoder/1/basis_transcoder.wasm`,\r\n};\r\n\r\n/**\r\n * Get the internal format to be passed to texImage2D corresponding to the .basis format value\r\n * @param basisFormat format chosen from GetSupportedTranscodeFormat\r\n * @param engine\r\n * @returns internal format corresponding to the Basis format\r\n */\r\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\r\nexport const GetInternalFormatFromBasisFormat = (basisFormat: number, engine: Engine) => {\r\n    let format;\r\n    switch (basisFormat) {\r\n        case BASIS_FORMATS.cTFETC1:\r\n            format = Constants.TEXTUREFORMAT_COMPRESSED_RGB_ETC1_WEBGL;\r\n            break;\r\n        case BASIS_FORMATS.cTFBC1:\r\n            format = Constants.TEXTUREFORMAT_COMPRESSED_RGB_S3TC_DXT1;\r\n            break;\r\n        case BASIS_FORMATS.cTFBC4:\r\n            format = Constants.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT5;\r\n            break;\r\n        case BASIS_FORMATS.cTFASTC_4x4:\r\n            format = Constants.TEXTUREFORMAT_COMPRESSED_RGBA_ASTC_4x4;\r\n            break;\r\n        case BASIS_FORMATS.cTFETC2:\r\n            format = Constants.TEXTUREFORMAT_COMPRESSED_RGBA8_ETC2_EAC;\r\n            break;\r\n        case BASIS_FORMATS.cTFBC7:\r\n            format = Constants.TEXTUREFORMAT_COMPRESSED_RGBA_BPTC_UNORM;\r\n            break;\r\n    }\r\n\r\n    if (format === undefined) {\r\n        // eslint-disable-next-line no-throw-literal\r\n        throw \"The chosen Basis transcoder format is not currently supported\";\r\n    }\r\n\r\n    return format;\r\n};\r\n\r\nlet _WorkerPromise: Nullable<Promise<Worker>> = null;\r\nlet _Worker: Nullable<Worker> = null;\r\nlet _actionId = 0;\r\nconst _IgnoreSupportedFormats = false;\r\nconst _CreateWorkerAsync = () => {\r\n    if (!_WorkerPromise) {\r\n        _WorkerPromise = new Promise((res, reject) => {\r\n            if (_Worker) {\r\n                res(_Worker);\r\n            } else {\r\n                Tools.LoadFileAsync(Tools.GetBabylonScriptURL(BasisToolsOptions.WasmModuleURL))\r\n                    .then((wasmBinary) => {\r\n                        if (typeof URL !== \"function\") {\r\n                            return reject(\"Basis transcoder requires an environment with a URL constructor\");\r\n                        }\r\n                        const workerBlobUrl = URL.createObjectURL(new Blob([`(${workerFunction})()`], { type: \"application/javascript\" }));\r\n                        _Worker = new Worker(workerBlobUrl);\r\n                        initializeWebWorker(_Worker, wasmBinary, BasisToolsOptions.JSModuleURL).then(res, reject);\r\n                    })\r\n                    .catch(reject);\r\n            }\r\n        });\r\n    }\r\n    return _WorkerPromise;\r\n};\r\n\r\n/**\r\n * Set the worker to use for transcoding\r\n * @param worker The worker that will be used for transcoding\r\n */\r\nexport const SetBasisTranscoderWorker = (worker: Worker) => {\r\n    _Worker = worker;\r\n};\r\n\r\n/**\r\n * Transcodes a loaded image file to compressed pixel data\r\n * @param data image data to transcode\r\n * @param config configuration options for the transcoding\r\n * @returns a promise resulting in the transcoded image\r\n */\r\nexport const TranscodeAsync = (data: ArrayBuffer | ArrayBufferView, config: BasisTranscodeConfiguration): Promise<TranscodeResult> => {\r\n    const dataView = data instanceof ArrayBuffer ? new Uint8Array(data) : data;\r\n\r\n    return new Promise((res, rej) => {\r\n        _CreateWorkerAsync().then(\r\n            () => {\r\n                const actionId = _actionId++;\r\n                const messageHandler = (msg: any) => {\r\n                    if (msg.data.action === \"transcode\" && msg.data.id === actionId) {\r\n                        _Worker!.removeEventListener(\"message\", messageHandler);\r\n                        if (!msg.data.success) {\r\n                            rej(\"Transcode is not supported on this device\");\r\n                        } else {\r\n                            res(msg.data);\r\n                        }\r\n                    }\r\n                };\r\n                _Worker!.addEventListener(\"message\", messageHandler);\r\n\r\n                const dataViewCopy = new Uint8Array(dataView.byteLength);\r\n                dataViewCopy.set(new Uint8Array(dataView.buffer, dataView.byteOffset, dataView.byteLength));\r\n                _Worker!.postMessage({ action: \"transcode\", id: actionId, imageData: dataViewCopy, config: config, ignoreSupportedFormats: _IgnoreSupportedFormats }, [\r\n                    dataViewCopy.buffer,\r\n                ]);\r\n            },\r\n            (error) => {\r\n                rej(error);\r\n            }\r\n        );\r\n    });\r\n};\r\n\r\n/**\r\n * Binds a texture according to its underlying target.\r\n * @param texture texture to bind\r\n * @param engine the engine to bind the texture in\r\n */\r\nconst BindTexture = (texture: InternalTexture, engine: Engine): void => {\r\n    let target: GLenum = engine._gl?.TEXTURE_2D;\r\n    if (texture.isCube) {\r\n        target = engine._gl?.TEXTURE_CUBE_MAP;\r\n    }\r\n\r\n    engine._bindTextureDirectly(target, texture, true);\r\n};\r\n\r\n/**\r\n * Loads a texture from the transcode result\r\n * @param texture texture load to\r\n * @param transcodeResult the result of transcoding the basis file to load from\r\n */\r\nexport const LoadTextureFromTranscodeResult = (texture: InternalTexture, transcodeResult: TranscodeResult) => {\r\n    const engine = texture.getEngine() as Engine;\r\n    for (let i = 0; i < transcodeResult.fileInfo.images.length; i++) {\r\n        const rootImage = transcodeResult.fileInfo.images[i].levels[0];\r\n        texture._invertVScale = texture.invertY;\r\n        if (transcodeResult.format === -1 || transcodeResult.format === BASIS_FORMATS.cTFRGB565) {\r\n            // No compatable compressed format found, fallback to RGB\r\n            texture.type = Constants.TEXTURETYPE_UNSIGNED_SHORT_5_6_5;\r\n            texture.format = Constants.TEXTUREFORMAT_RGB;\r\n\r\n            if (engine._features.basisNeedsPOT && (Scalar.Log2(rootImage.width) % 1 !== 0 || Scalar.Log2(rootImage.height) % 1 !== 0)) {\r\n                // Create non power of two texture\r\n                const source = new InternalTexture(engine, InternalTextureSource.Temp);\r\n\r\n                texture._invertVScale = texture.invertY;\r\n                source.type = Constants.TEXTURETYPE_UNSIGNED_SHORT_5_6_5;\r\n                source.format = Constants.TEXTUREFORMAT_RGB;\r\n                // Fallback requires aligned width/height\r\n                source.width = (rootImage.width + 3) & ~3;\r\n                source.height = (rootImage.height + 3) & ~3;\r\n                BindTexture(source, engine);\r\n                engine._uploadDataToTextureDirectly(source, new Uint16Array(rootImage.transcodedPixels.buffer), i, 0, Constants.TEXTUREFORMAT_RGB, true);\r\n\r\n                // Resize to power of two\r\n                engine._rescaleTexture(source, texture, engine.scenes[0], engine._getInternalFormat(Constants.TEXTUREFORMAT_RGB), () => {\r\n                    engine._releaseTexture(source);\r\n                    BindTexture(texture, engine);\r\n                });\r\n            } else {\r\n                // Fallback is already inverted\r\n                texture._invertVScale = !texture.invertY;\r\n\r\n                // Upload directly\r\n                texture.width = (rootImage.width + 3) & ~3;\r\n                texture.height = (rootImage.height + 3) & ~3;\r\n                texture.samplingMode = Constants.TEXTURE_LINEAR_LINEAR;\r\n                BindTexture(texture, engine);\r\n                engine._uploadDataToTextureDirectly(texture, new Uint16Array(rootImage.transcodedPixels.buffer), i, 0, Constants.TEXTUREFORMAT_RGB, true);\r\n            }\r\n        } else {\r\n            texture.width = rootImage.width;\r\n            texture.height = rootImage.height;\r\n            texture.generateMipMaps = transcodeResult.fileInfo.images[i].levels.length > 1;\r\n\r\n            const format = BasisTools.GetInternalFormatFromBasisFormat(transcodeResult.format!, engine);\r\n            texture.format = format;\r\n\r\n            BindTexture(texture, engine);\r\n\r\n            // Upload all mip levels in the file\r\n            transcodeResult.fileInfo.images[i].levels.forEach((level: any, index: number) => {\r\n                engine._uploadCompressedDataToTextureDirectly(texture, format, level.width, level.height, level.transcodedPixels, i, index);\r\n            });\r\n\r\n            if (engine._features.basisNeedsPOT && (Scalar.Log2(texture.width) % 1 !== 0 || Scalar.Log2(texture.height) % 1 !== 0)) {\r\n                Tools.Warn(\r\n                    \"Loaded .basis texture width and height are not a power of two. Texture wrapping will be set to Texture.CLAMP_ADDRESSMODE as other modes are not supported with non power of two dimensions in webGL 1.\"\r\n                );\r\n                texture._cachedWrapU = Texture.CLAMP_ADDRESSMODE;\r\n                texture._cachedWrapV = Texture.CLAMP_ADDRESSMODE;\r\n            }\r\n        }\r\n    }\r\n};\r\n\r\n/**\r\n * Used to load .Basis files\r\n * See https://github.com/BinomialLLC/basis_universal/tree/master/webgl\r\n */\r\nexport const BasisTools = {\r\n    /**\r\n     * URL to use when loading the basis transcoder\r\n     */\r\n    JSModuleURL: BasisToolsOptions.JSModuleURL,\r\n    /**\r\n     * URL to use when loading the wasm module for the transcoder\r\n     */\r\n    WasmModuleURL: BasisToolsOptions.WasmModuleURL,\r\n\r\n    /**\r\n     * Get the internal format to be passed to texImage2D corresponding to the .basis format value\r\n     * @param basisFormat format chosen from GetSupportedTranscodeFormat\r\n     * @returns internal format corresponding to the Basis format\r\n     */\r\n    GetInternalFormatFromBasisFormat,\r\n\r\n    /**\r\n     * Transcodes a loaded image file to compressed pixel data\r\n     * @param data image data to transcode\r\n     * @param config configuration options for the transcoding\r\n     * @returns a promise resulting in the transcoded image\r\n     */\r\n    TranscodeAsync,\r\n\r\n    /**\r\n     * Loads a texture from the transcode result\r\n     * @param texture texture load to\r\n     * @param transcodeResult the result of transcoding the basis file to load from\r\n     */\r\n    LoadTextureFromTranscodeResult,\r\n};\r\n\r\nObject.defineProperty(BasisTools, \"JSModuleURL\", {\r\n    get: function (this: null) {\r\n        return BasisToolsOptions.JSModuleURL;\r\n    },\r\n    set: function (this: null, value: string) {\r\n        BasisToolsOptions.JSModuleURL = value;\r\n    },\r\n});\r\n\r\nObject.defineProperty(BasisTools, \"WasmModuleURL\", {\r\n    get: function (this: null) {\r\n        return BasisToolsOptions.WasmModuleURL;\r\n    },\r\n    set: function (this: null, value: string) {\r\n        BasisToolsOptions.WasmModuleURL = value;\r\n    },\r\n});\r\n","/* eslint-disable @typescript-eslint/naming-convention */\r\nimport type { Nullable } from \"core/types\";\r\nimport { Tools } from \"./tools\";\r\nimport type { BasisFileInfo, BasisTranscodeConfiguration } from \"./basis\";\r\n\r\n// WorkerGlobalScope\r\ndeclare function importScripts(...urls: string[]): void;\r\ndeclare function postMessage(message: any, transfer?: any[]): void;\r\ndeclare let BASIS: any;\r\n/**\r\n * The worker function that gets converted to a blob url to pass into a worker.\r\n * To be used if a developer wants to create their own worker instance and inject it instead of using the default worker.\r\n */\r\nexport function workerFunction(): void {\r\n    const _BASIS_FORMAT = {\r\n        cTFETC1: 0,\r\n        cTFETC2: 1,\r\n        cTFBC1: 2,\r\n        cTFBC3: 3,\r\n        cTFBC4: 4,\r\n        cTFBC5: 5,\r\n        cTFBC7: 6,\r\n        cTFPVRTC1_4_RGB: 8,\r\n        cTFPVRTC1_4_RGBA: 9,\r\n        cTFASTC_4x4: 10,\r\n        cTFATC_RGB: 11,\r\n        cTFATC_RGBA_INTERPOLATED_ALPHA: 12,\r\n        cTFRGBA32: 13,\r\n        cTFRGB565: 14,\r\n        cTFBGR565: 15,\r\n        cTFRGBA4444: 16,\r\n        cTFFXT1_RGB: 17,\r\n        cTFPVRTC2_4_RGB: 18,\r\n        cTFPVRTC2_4_RGBA: 19,\r\n        cTFETC2_EAC_R11: 20,\r\n        cTFETC2_EAC_RG11: 21,\r\n    };\r\n    let transcoderModulePromise: Nullable<PromiseLike<any>> = null;\r\n    onmessage = (event) => {\r\n        if (event.data.action === \"init\") {\r\n            // Load the transcoder if it hasn't been yet\r\n            if (event.data.url) {\r\n                // make sure we loaded the script correctly\r\n                try {\r\n                    importScripts(event.data.url);\r\n                } catch (e) {\r\n                    postMessage({ action: \"error\", error: e });\r\n                }\r\n            }\r\n            if (!transcoderModulePromise) {\r\n                transcoderModulePromise = BASIS({\r\n                    // Override wasm binary\r\n                    wasmBinary: event.data.wasmBinary,\r\n                });\r\n            }\r\n            if (transcoderModulePromise !== null) {\r\n                transcoderModulePromise.then((m) => {\r\n                    BASIS = m;\r\n                    m.initializeBasis();\r\n                    postMessage({ action: \"init\" });\r\n                });\r\n            }\r\n        } else if (event.data.action === \"transcode\") {\r\n            // Transcode the basis image and return the resulting pixels\r\n            const config: BasisTranscodeConfiguration = event.data.config;\r\n            const imgData = event.data.imageData;\r\n            const loadedFile = new BASIS.BasisFile(imgData);\r\n            const fileInfo = GetFileInfo(loadedFile);\r\n            let format = event.data.ignoreSupportedFormats ? null : GetSupportedTranscodeFormat(event.data.config, fileInfo);\r\n\r\n            let needsConversion = false;\r\n            if (format === null) {\r\n                needsConversion = true;\r\n                format = fileInfo.hasAlpha ? _BASIS_FORMAT.cTFBC3 : _BASIS_FORMAT.cTFBC1;\r\n            }\r\n\r\n            // Begin transcode\r\n            let success = true;\r\n            if (!loadedFile.startTranscoding()) {\r\n                success = false;\r\n            }\r\n\r\n            const buffers: Array<any> = [];\r\n            for (let imageIndex = 0; imageIndex < fileInfo.images.length; imageIndex++) {\r\n                if (!success) {\r\n                    break;\r\n                }\r\n                const image = fileInfo.images[imageIndex];\r\n                if (config.loadSingleImage === undefined || config.loadSingleImage === imageIndex) {\r\n                    let mipCount = image.levels.length;\r\n                    if (config.loadMipmapLevels === false) {\r\n                        mipCount = 1;\r\n                    }\r\n                    for (let levelIndex = 0; levelIndex < mipCount; levelIndex++) {\r\n                        const levelInfo = image.levels[levelIndex];\r\n\r\n                        const pixels = TranscodeLevel(loadedFile, imageIndex, levelIndex, format!, needsConversion);\r\n                        if (!pixels) {\r\n                            success = false;\r\n                            break;\r\n                        }\r\n                        levelInfo.transcodedPixels = pixels;\r\n                        buffers.push(levelInfo.transcodedPixels.buffer);\r\n                    }\r\n                }\r\n            }\r\n            // Close file\r\n            loadedFile.close();\r\n            loadedFile.delete();\r\n\r\n            if (needsConversion) {\r\n                format = -1;\r\n            }\r\n            if (!success) {\r\n                postMessage({ action: \"transcode\", success: success, id: event.data.id });\r\n            } else {\r\n                postMessage({ action: \"transcode\", success: success, id: event.data.id, fileInfo: fileInfo, format: format }, buffers);\r\n            }\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Detects the supported transcode format for the file\r\n     * @param config transcode config\r\n     * @param fileInfo info about the file\r\n     * @returns the chosed format or null if none are supported\r\n     */\r\n    function GetSupportedTranscodeFormat(config: BasisTranscodeConfiguration, fileInfo: BasisFileInfo): Nullable<number> {\r\n        let format = null;\r\n        if (config.supportedCompressionFormats) {\r\n            if (config.supportedCompressionFormats.astc) {\r\n                format = _BASIS_FORMAT.cTFASTC_4x4;\r\n            } else if (config.supportedCompressionFormats.bc7) {\r\n                format = _BASIS_FORMAT.cTFBC7;\r\n            } else if (config.supportedCompressionFormats.s3tc) {\r\n                format = fileInfo.hasAlpha ? _BASIS_FORMAT.cTFBC3 : _BASIS_FORMAT.cTFBC1;\r\n            } else if (config.supportedCompressionFormats.pvrtc) {\r\n                format = fileInfo.hasAlpha ? _BASIS_FORMAT.cTFPVRTC1_4_RGBA : _BASIS_FORMAT.cTFPVRTC1_4_RGB;\r\n            } else if (config.supportedCompressionFormats.etc2) {\r\n                format = _BASIS_FORMAT.cTFETC2;\r\n            } else if (config.supportedCompressionFormats.etc1) {\r\n                format = _BASIS_FORMAT.cTFETC1;\r\n            } else {\r\n                format = _BASIS_FORMAT.cTFRGB565;\r\n            }\r\n        }\r\n        return format;\r\n    }\r\n\r\n    /**\r\n     * Retrieves information about the basis file eg. dimensions\r\n     * @param basisFile the basis file to get the info from\r\n     * @returns information about the basis file\r\n     */\r\n    function GetFileInfo(basisFile: any): BasisFileInfo {\r\n        const hasAlpha = basisFile.getHasAlpha();\r\n        const imageCount = basisFile.getNumImages();\r\n        const images = [];\r\n        for (let i = 0; i < imageCount; i++) {\r\n            const imageInfo = {\r\n                levels: [] as Array<any>,\r\n            };\r\n            const levelCount = basisFile.getNumLevels(i);\r\n            for (let level = 0; level < levelCount; level++) {\r\n                const levelInfo = {\r\n                    width: basisFile.getImageWidth(i, level),\r\n                    height: basisFile.getImageHeight(i, level),\r\n                };\r\n                imageInfo.levels.push(levelInfo);\r\n            }\r\n            images.push(imageInfo);\r\n        }\r\n        const info = { hasAlpha, images };\r\n        return info;\r\n    }\r\n\r\n    function TranscodeLevel(loadedFile: any, imageIndex: number, levelIndex: number, format: number, convertToRgb565: boolean): Nullable<Uint8Array | Uint16Array> {\r\n        const dstSize = loadedFile.getImageTranscodedSizeInBytes(imageIndex, levelIndex, format);\r\n        let dst: Uint8Array | Uint16Array = new Uint8Array(dstSize);\r\n        if (!loadedFile.transcodeImage(dst, imageIndex, levelIndex, format, 1, 0)) {\r\n            return null;\r\n        }\r\n        // If no supported format is found, load as dxt and convert to rgb565\r\n        if (convertToRgb565) {\r\n            const alignedWidth = (loadedFile.getImageWidth(imageIndex, levelIndex) + 3) & ~3;\r\n            const alignedHeight = (loadedFile.getImageHeight(imageIndex, levelIndex) + 3) & ~3;\r\n            dst = ConvertDxtToRgb565(dst, 0, alignedWidth, alignedHeight);\r\n        }\r\n        return dst;\r\n    }\r\n\r\n    /**\r\n     * From https://github.com/BinomialLLC/basis_universal/blob/master/webgl/texture/dxt-to-rgb565.js\r\n     * An unoptimized version of dxtToRgb565.  Also, the floating\r\n     * point math used to compute the colors actually results in\r\n     * slightly different colors compared to hardware DXT decoders.\r\n     * @param src dxt src pixels\r\n     * @param srcByteOffset offset for the start of src\r\n     * @param  width aligned width of the image\r\n     * @param  height aligned height of the image\r\n     * @returns the converted pixels\r\n     */\r\n    function ConvertDxtToRgb565(src: Uint8Array, srcByteOffset: number, width: number, height: number): Uint16Array {\r\n        const c = new Uint16Array(4);\r\n        const dst = new Uint16Array(width * height);\r\n\r\n        const blockWidth = width / 4;\r\n        const blockHeight = height / 4;\r\n        for (let blockY = 0; blockY < blockHeight; blockY++) {\r\n            for (let blockX = 0; blockX < blockWidth; blockX++) {\r\n                const i = srcByteOffset + 8 * (blockY * blockWidth + blockX);\r\n                c[0] = src[i] | (src[i + 1] << 8);\r\n                c[1] = src[i + 2] | (src[i + 3] << 8);\r\n                c[2] =\r\n                    ((2 * (c[0] & 0x1f) + 1 * (c[1] & 0x1f)) / 3) |\r\n                    (((2 * (c[0] & 0x7e0) + 1 * (c[1] & 0x7e0)) / 3) & 0x7e0) |\r\n                    (((2 * (c[0] & 0xf800) + 1 * (c[1] & 0xf800)) / 3) & 0xf800);\r\n                c[3] =\r\n                    ((2 * (c[1] & 0x1f) + 1 * (c[0] & 0x1f)) / 3) |\r\n                    (((2 * (c[1] & 0x7e0) + 1 * (c[0] & 0x7e0)) / 3) & 0x7e0) |\r\n                    (((2 * (c[1] & 0xf800) + 1 * (c[0] & 0xf800)) / 3) & 0xf800);\r\n                for (let row = 0; row < 4; row++) {\r\n                    const m = src[i + 4 + row];\r\n                    let dstI = (blockY * 4 + row) * width + blockX * 4;\r\n                    dst[dstI++] = c[m & 0x3];\r\n                    dst[dstI++] = c[(m >> 2) & 0x3];\r\n                    dst[dstI++] = c[(m >> 4) & 0x3];\r\n                    dst[dstI++] = c[(m >> 6) & 0x3];\r\n                }\r\n            }\r\n        }\r\n        return dst;\r\n    }\r\n}\r\n\r\n/**\r\n * Initialize a web worker with the basis transcoder\r\n * @param worker the worker to initialize\r\n * @param wasmBinary the wasm binary to load into the worker\r\n * @param moduleUrl the url to the basis transcoder module\r\n * @returns a promise that resolves when the worker is initialized\r\n */\r\nexport function initializeWebWorker(worker: Worker, wasmBinary: ArrayBuffer, moduleUrl?: string) {\r\n    return new Promise<Worker>((res, reject) => {\r\n        const initHandler = (msg: any) => {\r\n            if (msg.data.action === \"init\") {\r\n                worker!.removeEventListener(\"message\", initHandler);\r\n                res(worker!);\r\n            } else if (msg.data.action === \"error\") {\r\n                reject(msg.data.error || \"error initializing worker\");\r\n            }\r\n        };\r\n        worker.addEventListener(\"message\", initHandler);\r\n        // we can use transferable objects here because the worker will own the ArrayBuffer\r\n        worker.postMessage({ action: \"init\", url: moduleUrl ? Tools.GetBabylonScriptURL(moduleUrl) : undefined, wasmBinary }, [wasmBinary]);\r\n    });\r\n}\r\n","import type { Nullable } from \"../../../types\";\r\nimport type { InternalTexture } from \"../../../Materials/Textures/internalTexture\";\r\nimport type { IInternalTextureLoader } from \"./internalTextureLoader\";\r\nimport { LoadTextureFromTranscodeResult, TranscodeAsync } from \"../../../Misc/basis\";\r\nimport { Tools } from \"../../../Misc/tools\";\r\n\r\nimport \"../../../Engines/Extensions/engine.cubeTexture\";\r\n\r\n/**\r\n * Loader for .basis file format\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport class _BasisTextureLoader implements IInternalTextureLoader {\r\n    /**\r\n     * Defines whether the loader supports cascade loading the different faces.\r\n     */\r\n    public readonly supportCascades = false;\r\n\r\n    /**\r\n     * Uploads the cube texture data to the WebGL texture. It has already been bound.\r\n     * @param data contains the texture data\r\n     * @param texture defines the BabylonJS internal texture\r\n     * @param createPolynomials will be true if polynomials have been requested\r\n     * @param onLoad defines the callback to trigger once the texture is ready\r\n     * @param onError defines the callback to trigger in case of error\r\n     */\r\n    public loadCubeData(\r\n        data: ArrayBufferView | ArrayBufferView[],\r\n        texture: InternalTexture,\r\n        createPolynomials: boolean,\r\n        onLoad: Nullable<(data?: any) => void>,\r\n        onError: Nullable<(message?: string, exception?: any) => void>\r\n    ): void {\r\n        if (Array.isArray(data)) {\r\n            return;\r\n        }\r\n        const caps = texture.getEngine().getCaps();\r\n        const transcodeConfig = {\r\n            supportedCompressionFormats: {\r\n                etc1: caps.etc1 ? true : false,\r\n                s3tc: caps.s3tc ? true : false,\r\n                pvrtc: caps.pvrtc ? true : false,\r\n                etc2: caps.etc2 ? true : false,\r\n                astc: caps.astc ? true : false,\r\n                bc7: caps.bptc ? true : false,\r\n            },\r\n        };\r\n        TranscodeAsync(data, transcodeConfig)\r\n            .then((result) => {\r\n                const hasMipmap = result.fileInfo.images[0].levels.length > 1 && texture.generateMipMaps;\r\n                LoadTextureFromTranscodeResult(texture, result);\r\n                texture.getEngine()._setCubeMapTextureParams(texture, hasMipmap);\r\n                texture.isReady = true;\r\n                texture.onLoadedObservable.notifyObservers(texture);\r\n                texture.onLoadedObservable.clear();\r\n                if (onLoad) {\r\n                    onLoad();\r\n                }\r\n            })\r\n            .catch((err) => {\r\n                const errorMessage = \"Failed to transcode Basis file, transcoding may not be supported on this device\";\r\n                Tools.Warn(errorMessage);\r\n                texture.isReady = true;\r\n                if (onError) {\r\n                    onError(err);\r\n                }\r\n            });\r\n    }\r\n\r\n    /**\r\n     * Uploads the 2D texture data to the WebGL texture. It has already been bound once in the callback.\r\n     * @param data contains the texture data\r\n     * @param texture defines the BabylonJS internal texture\r\n     * @param callback defines the method to call once ready to upload\r\n     */\r\n    public loadData(\r\n        data: ArrayBufferView,\r\n        texture: InternalTexture,\r\n        callback: (width: number, height: number, loadMipmap: boolean, isCompressed: boolean, done: () => void, failedLoading?: boolean) => void\r\n    ): void {\r\n        const caps = texture.getEngine().getCaps();\r\n        const transcodeConfig = {\r\n            supportedCompressionFormats: {\r\n                etc1: caps.etc1 ? true : false,\r\n                s3tc: caps.s3tc ? true : false,\r\n                pvrtc: caps.pvrtc ? true : false,\r\n                etc2: caps.etc2 ? true : false,\r\n                astc: caps.astc ? true : false,\r\n                bc7: caps.bptc ? true : false,\r\n            },\r\n        };\r\n        TranscodeAsync(data, transcodeConfig)\r\n            .then((result) => {\r\n                const rootImage = result.fileInfo.images[0].levels[0];\r\n                const hasMipmap = result.fileInfo.images[0].levels.length > 1 && texture.generateMipMaps;\r\n                callback(rootImage.width, rootImage.height, hasMipmap, result.format !== -1, () => {\r\n                    LoadTextureFromTranscodeResult(texture, result);\r\n                });\r\n            })\r\n            .catch((err) => {\r\n                Tools.Warn(\"Failed to transcode Basis file, transcoding may not be supported on this device\");\r\n                Tools.Warn(`Failed to transcode Basis file: ${err}`);\r\n                callback(0, 0, false, false, () => {}, true);\r\n            });\r\n    }\r\n}\r\n"],"names":["BASIS_FORMATS","workerFunction","_BASIS_FORMAT","transcoderModulePromise","TranscodeLevel","loadedFile","imageIndex","levelIndex","format","convertToRgb565","dstSize","getImageTranscodedSizeInBytes","dst","Uint8Array","transcodeImage","src","srcByteOffset","width","height","c","Uint16Array","blockWidth","blockHeight","blockY","blockX","i","row","m","dstI","ConvertDxtToRgb565","getImageWidth","getImageHeight","onmessage","event","data","action","url","importScripts","e","postMessage","error","BASIS","wasmBinary","then","initializeBasis","config","imgData","imageData","BasisFile","fileInfo","basisFile","hasAlpha","getHasAlpha","imageCount","getNumImages","images","imageInfo","levels","levelCount","getNumLevels","level","levelInfo","push","GetFileInfo","ignoreSupportedFormats","supportedCompressionFormats","astc","bc7","s3tc","pvrtc","etc2","etc1","GetSupportedTranscodeFormat","needsConversion","success","startTranscoding","buffers","length","image","undefined","loadSingleImage","mipCount","loadMipmapLevels","pixels","transcodedPixels","buffer","close","delete","id","BasisToolsOptions","JSModuleURL","Tools","_DefaultCdnUrl","WasmModuleURL","_WorkerPromise","_Worker","_actionId","_CreateWorkerAsync","Promise","res","reject","LoadFileAsync","GetBabylonScriptURL","URL","workerBlobUrl","createObjectURL","Blob","type","Worker","worker","moduleUrl","initHandler","msg","removeEventListener","addEventListener","initializeWebWorker","catch","TranscodeAsync","dataView","ArrayBuffer","rej","actionId","messageHandler","dataViewCopy","byteLength","set","byteOffset","BindTexture","texture","engine","target","_gl","TEXTURE_2D","isCube","TEXTURE_CUBE_MAP","_bindTextureDirectly","LoadTextureFromTranscodeResult","transcodeResult","getEngine","rootImage","_invertVScale","invertY","cTFRGB565","_features","basisNeedsPOT","Scalar","Log2","samplingMode","_uploadDataToTextureDirectly","source","InternalTexture","_rescaleTexture","scenes","_getInternalFormat","_releaseTexture","generateMipMaps","BasisTools","GetInternalFormatFromBasisFormat","forEach","index","_uploadCompressedDataToTextureDirectly","Warn","_cachedWrapU","Texture","CLAMP_ADDRESSMODE","_cachedWrapV","basisFormat","cTFETC1","cTFBC1","cTFBC4","cTFASTC_4x4","cTFETC2","cTFBC7","Object","defineProperty","get","value","_BasisTextureLoader","constructor","supportCascades","loadCubeData","createPolynomials","onLoad","onError","Array","isArray","caps","getCaps","transcodeConfig","bptc","result","hasMipmap","_setCubeMapTextureParams","isReady","onLoadedObservable","notifyObservers","clear","err","loadData","callback"],"sourceRoot":""}