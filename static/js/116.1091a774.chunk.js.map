{"version":3,"file":"static/js/116.1091a774.chunk.js","mappings":"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","sources":["../dev/core/src/Materials/Textures/Loaders/EXR/exrLoader.interfaces.ts","../dev/core/src/Materials/Textures/Loaders/EXR/exrLoader.core.ts","../dev/core/src/Materials/Textures/Loaders/EXR/exrLoader.compression.huf.ts","../dev/core/src/Materials/Textures/Loaders/EXR/exrLoader.compression.ts","../dev/core/src/Materials/Textures/Loaders/EXR/exrLoader.compression.rle.ts","../dev/core/src/Materials/Textures/Loaders/EXR/exrLoader.configuration.ts","../dev/core/src/Materials/Textures/Loaders/exrTextureLoader.ts","../dev/core/src/Materials/Textures/Loaders/EXR/exrLoader.header.ts","../dev/core/src/Materials/Textures/Loaders/EXR/exrLoader.decoder.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/naming-convention */\r\nimport type { Nullable } from \"core/types\";\r\nimport type { DataCursor } from \"./exrLoader.core\";\r\n\r\nexport const INT32_SIZE = 4;\r\nexport const FLOAT32_SIZE = 4;\r\nexport const INT8_SIZE = 1;\r\nexport const INT16_SIZE = 2;\r\nexport const ULONG_SIZE = 8;\r\nexport const USHORT_RANGE = 1 << 16;\r\nexport const BITMAP_SIZE = USHORT_RANGE >> 3;\r\nexport const HUF_ENCBITS = 16;\r\nexport const HUF_DECBITS = 14;\r\nexport const HUF_ENCSIZE = (1 << HUF_ENCBITS) + 1;\r\nexport const HUF_DECSIZE = 1 << HUF_DECBITS;\r\nexport const HUF_DECMASK = HUF_DECSIZE - 1;\r\nexport const SHORT_ZEROCODE_RUN = 59;\r\nexport const LONG_ZEROCODE_RUN = 63;\r\nexport const SHORTEST_LONG_RUN = 2 + LONG_ZEROCODE_RUN - SHORT_ZEROCODE_RUN;\r\n\r\nexport interface IEXRCHannel {\r\n    name: string;\r\n    pixelType: number;\r\n}\r\n\r\nexport interface IDecodeChannel {\r\n    [name: string]: number;\r\n}\r\n\r\n/**\r\n * Interface used to define the EXR header\r\n */\r\nexport interface IEXRHeader {\r\n    /** Version */\r\n    version: number;\r\n    /** Specifications */\r\n    spec: {\r\n        singleTile: boolean;\r\n        longName: boolean;\r\n        deepFormat: boolean;\r\n        multiPart: boolean;\r\n    };\r\n    /** Data window */\r\n    dataWindow: {\r\n        xMin: number;\r\n        xMax: number;\r\n        yMin: number;\r\n        yMax: number;\r\n    };\r\n    /** Channels */\r\n    channels: IEXRCHannel[];\r\n    /** Extra data */\r\n    [name: string]: any;\r\n}\r\n\r\nexport interface IEXRDecoder {\r\n    size: number;\r\n    viewer: DataView;\r\n    array: Uint8Array;\r\n    byteArray: Nullable<Float32Array | Uint16Array>;\r\n    offset: DataCursor;\r\n    width: number;\r\n    height: number;\r\n    channels: number;\r\n    channelLineOffsets: IDecodeChannel;\r\n    scanOrder: (value: number) => number;\r\n    bytesPerLine: number;\r\n    outLineWidth: number;\r\n    lines: number;\r\n    scanlineBlockSize: number;\r\n    inputSize: Nullable<number>;\r\n    type: number;\r\n    uncompress: Nullable<(decoder: IEXRDecoder) => DataView>;\r\n    getter: (dataView: DataView, offset: DataCursor) => number;\r\n    format: number;\r\n    outputChannels: number;\r\n    decodeChannels: IDecodeChannel;\r\n    blockCount: Nullable<number>;\r\n    linearSpace: boolean;\r\n    textureType: number;\r\n}\r\n","import { Clamp } from \"core/Maths/math.scalar.functions\";\r\nimport { FLOAT32_SIZE, INT16_SIZE, INT32_SIZE, INT8_SIZE, ULONG_SIZE } from \"./exrLoader.interfaces\";\r\n\r\n/**\r\n * Inspired by https://github.com/sciecode/three.js/blob/dev/examples/jsm/loaders/EXRLoader.js\r\n * Referred to the original Industrial Light & Magic OpenEXR implementation and the TinyEXR / Syoyo Fujita\r\n * implementation.\r\n */\r\n\r\n// /*\r\n// Copyright (c) 2014 - 2017, Syoyo Fujita\r\n// All rights reserved.\r\n\r\n// Redistribution and use in source and binary forms, with or without\r\n// modification, are permitted provided that the following conditions are met:\r\n//     * Redistributions of source code must retain the above copyright\r\n//       notice, this list of conditions and the following disclaimer.\r\n//     * Redistributions in binary form must reproduce the above copyright\r\n//       notice, this list of conditions and the following disclaimer in the\r\n//       documentation and/or other materials provided with the distribution.\r\n//     * Neither the name of the Syoyo Fujita nor the\r\n//       names of its contributors may be used to endorse or promote products\r\n//       derived from this software without specific prior written permission.\r\n\r\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\r\n// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\r\n// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\r\n// DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY\r\n// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\r\n// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\r\n// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\r\n// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\r\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\r\n// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\r\n// */\r\n\r\n// // TinyEXR contains some OpenEXR code, which is licensed under ------------\r\n\r\n// ///////////////////////////////////////////////////////////////////////////\r\n// //\r\n// // Copyright (c) 2002, Industrial Light & Magic, a division of Lucas\r\n// // Digital Ltd. LLC\r\n// //\r\n// // All rights reserved.\r\n// //\r\n// // Redistribution and use in source and binary forms, with or without\r\n// // modification, are permitted provided that the following conditions are\r\n// // met:\r\n// // *       Redistributions of source code must retain the above copyright\r\n// // notice, this list of conditions and the following disclaimer.\r\n// // *       Redistributions in binary form must reproduce the above\r\n// // copyright notice, this list of conditions and the following disclaimer\r\n// // in the documentation and/or other materials provided with the\r\n// // distribution.\r\n// // *       Neither the name of Industrial Light & Magic nor the names of\r\n// // its contributors may be used to endorse or promote products derived\r\n// // from this software without specific prior written permission.\r\n// //\r\n// // THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\r\n// // \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\r\n// // LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\r\n// // A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\r\n// // OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\r\n// // SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\r\n// // LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\r\n// // DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\r\n// // THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\r\n// // (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\r\n// // OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\r\n// //\r\n// ///////////////////////////////////////////////////////////////////////////\r\n\r\n// // End of OpenEXR license -------------------------------------------------\r\n\r\nexport enum CompressionCodes {\r\n    NO_COMPRESSION,\r\n    RLE_COMPRESSION,\r\n    ZIPS_COMPRESSION,\r\n    ZIP_COMPRESSION,\r\n    PIZ_COMPRESSION,\r\n    PXR24_COMPRESSION,\r\n}\r\n\r\nenum LineOrders {\r\n    INCREASING_Y,\r\n    DECREASING_Y,\r\n}\r\n\r\n/**\r\n * Interface used to define the cursor position in the data\r\n */\r\nexport interface DataCursor {\r\n    /** Curosr position */\r\n    value: number;\r\n}\r\n\r\nconst _tables = _GenerateTables();\r\n\r\n// Fast Half Float Conversions, http://www.fox-toolkit.org/ftp/fasthalffloatconversion.pdf\r\nfunction _GenerateTables() {\r\n    // float32 to float16 helpers\r\n\r\n    const buffer = new ArrayBuffer(4);\r\n    const floatView = new Float32Array(buffer);\r\n    const uint32View = new Uint32Array(buffer);\r\n\r\n    const baseTable = new Uint32Array(512);\r\n    const shiftTable = new Uint32Array(512);\r\n\r\n    for (let i = 0; i < 256; ++i) {\r\n        const e = i - 127;\r\n\r\n        // very small number (0, -0)\r\n\r\n        if (e < -27) {\r\n            baseTable[i] = 0x0000;\r\n            baseTable[i | 0x100] = 0x8000;\r\n            shiftTable[i] = 24;\r\n            shiftTable[i | 0x100] = 24;\r\n\r\n            // small number (denorm)\r\n        } else if (e < -14) {\r\n            baseTable[i] = 0x0400 >> (-e - 14);\r\n            baseTable[i | 0x100] = (0x0400 >> (-e - 14)) | 0x8000;\r\n            shiftTable[i] = -e - 1;\r\n            shiftTable[i | 0x100] = -e - 1;\r\n\r\n            // normal number\r\n        } else if (e <= 15) {\r\n            baseTable[i] = (e + 15) << 10;\r\n            baseTable[i | 0x100] = ((e + 15) << 10) | 0x8000;\r\n            shiftTable[i] = 13;\r\n            shiftTable[i | 0x100] = 13;\r\n\r\n            // large number (Infinity, -Infinity)\r\n        } else if (e < 128) {\r\n            baseTable[i] = 0x7c00;\r\n            baseTable[i | 0x100] = 0xfc00;\r\n            shiftTable[i] = 24;\r\n            shiftTable[i | 0x100] = 24;\r\n\r\n            // stay (NaN, Infinity, -Infinity)\r\n        } else {\r\n            baseTable[i] = 0x7c00;\r\n            baseTable[i | 0x100] = 0xfc00;\r\n            shiftTable[i] = 13;\r\n            shiftTable[i | 0x100] = 13;\r\n        }\r\n    }\r\n\r\n    // float16 to float32 helpers\r\n    const mantissaTable = new Uint32Array(2048);\r\n    const exponentTable = new Uint32Array(64);\r\n    const offsetTable = new Uint32Array(64);\r\n\r\n    for (let i = 1; i < 1024; ++i) {\r\n        let m = i << 13; // zero pad mantissa bits\r\n        let e = 0; // zero exponent\r\n\r\n        // normalized\r\n        while ((m & 0x00800000) === 0) {\r\n            m <<= 1;\r\n            e -= 0x00800000; // decrement exponent\r\n        }\r\n\r\n        m &= ~0x00800000; // clear leading 1 bit\r\n        e += 0x38800000; // adjust bias\r\n\r\n        mantissaTable[i] = m | e;\r\n    }\r\n\r\n    for (let i = 1024; i < 2048; ++i) {\r\n        mantissaTable[i] = 0x38000000 + ((i - 1024) << 13);\r\n    }\r\n\r\n    for (let i = 1; i < 31; ++i) {\r\n        exponentTable[i] = i << 23;\r\n    }\r\n\r\n    exponentTable[31] = 0x47800000;\r\n    exponentTable[32] = 0x80000000;\r\n\r\n    for (let i = 33; i < 63; ++i) {\r\n        exponentTable[i] = 0x80000000 + ((i - 32) << 23);\r\n    }\r\n\r\n    exponentTable[63] = 0xc7800000;\r\n\r\n    for (let i = 1; i < 64; ++i) {\r\n        if (i !== 32) {\r\n            offsetTable[i] = 1024;\r\n        }\r\n    }\r\n\r\n    return {\r\n        floatView: floatView,\r\n        uint32View: uint32View,\r\n        baseTable: baseTable,\r\n        shiftTable: shiftTable,\r\n        mantissaTable: mantissaTable,\r\n        exponentTable: exponentTable,\r\n        offsetTable: offsetTable,\r\n    };\r\n}\r\n\r\n/**\r\n * Parse a null terminated string from the buffer\r\n * @param buffer buffer to read from\r\n * @param offset current offset in the buffer\r\n * @returns a string\r\n */\r\nexport function ParseNullTerminatedString(buffer: ArrayBuffer, offset: DataCursor) {\r\n    const uintBuffer = new Uint8Array(buffer);\r\n    let endOffset = 0;\r\n\r\n    while (uintBuffer[offset.value + endOffset] != 0) {\r\n        endOffset += 1;\r\n    }\r\n\r\n    const stringValue = new TextDecoder().decode(uintBuffer.slice(offset.value, offset.value + endOffset));\r\n\r\n    offset.value = offset.value + endOffset + 1;\r\n\r\n    return stringValue;\r\n}\r\n\r\n/**\r\n * Parse an int32 from the buffer\r\n * @param dataView dataview on the data\r\n * @param offset current offset in the data view\r\n * @returns an int32\r\n */\r\nexport function ParseInt32(dataView: DataView, offset: DataCursor) {\r\n    const value = dataView.getInt32(offset.value, true);\r\n\r\n    offset.value += INT32_SIZE;\r\n\r\n    return value;\r\n}\r\n\r\n/**\r\n * Parse an uint32 from the buffer\r\n * @param dataView data view to read from\r\n * @param offset offset in the data view\r\n * @returns an uint32\r\n */\r\nexport function ParseUint32(dataView: DataView, offset: DataCursor) {\r\n    const value = dataView.getUint32(offset.value, true);\r\n\r\n    offset.value += INT32_SIZE;\r\n\r\n    return value;\r\n}\r\n\r\n/**\r\n * Parse an uint8 from the buffer\r\n * @param dataView dataview on the data\r\n * @param offset current offset in the data view\r\n * @returns an uint8\r\n */\r\nexport function ParseUint8(dataView: DataView, offset: DataCursor) {\r\n    const value = dataView.getUint8(offset.value);\r\n\r\n    offset.value += INT8_SIZE;\r\n\r\n    return value;\r\n}\r\n\r\n/**\r\n * Parse an uint16 from the buffer\r\n * @param dataView dataview on the data\r\n * @param offset current offset in the data view\r\n * @returns an uint16\r\n */\r\nexport function ParseUint16(dataView: DataView, offset: DataCursor) {\r\n    const value = dataView.getUint16(offset.value, true);\r\n\r\n    offset.value += INT16_SIZE;\r\n\r\n    return value;\r\n}\r\n\r\n/**\r\n * Parse an uint8 from an array buffer\r\n * @param array array buffer\r\n * @param offset current offset in the data view\r\n * @returns an uint16\r\n */\r\nexport function ParseUint8Array(array: Uint8Array, offset: DataCursor) {\r\n    const value = array[offset.value];\r\n\r\n    offset.value += INT8_SIZE;\r\n\r\n    return value;\r\n}\r\n\r\n/**\r\n * Parse an int64 from the buffer\r\n * @param dataView dataview on the data\r\n * @param offset current offset in the data view\r\n * @returns an int64\r\n */\r\nexport function ParseInt64(dataView: DataView, offset: DataCursor) {\r\n    let int;\r\n\r\n    if (\"getBigInt64\" in DataView.prototype) {\r\n        int = Number(dataView.getBigInt64(offset.value, true));\r\n    } else {\r\n        int = dataView.getUint32(offset.value + 4, true) + Number(dataView.getUint32(offset.value, true) << 32);\r\n    }\r\n\r\n    offset.value += ULONG_SIZE;\r\n\r\n    return int;\r\n}\r\n\r\n/**\r\n * Parse a float32 from the buffer\r\n * @param dataView dataview on the data\r\n * @param offset current offset in the data view\r\n * @returns a float32\r\n */\r\nexport function ParseFloat32(dataView: DataView, offset: DataCursor) {\r\n    const value = dataView.getFloat32(offset.value, true);\r\n\r\n    offset.value += FLOAT32_SIZE;\r\n\r\n    return value;\r\n}\r\n\r\n/**\r\n * Parse a float16 from the buffer\r\n * @param dataView dataview on the data\r\n * @param offset current offset in the data view\r\n * @returns a float16\r\n */\r\nexport function ParseFloat16(dataView: DataView, offset: DataCursor) {\r\n    return DecodeFloat16(ParseUint16(dataView, offset));\r\n}\r\n\r\nfunction DecodeFloat16(binary: number) {\r\n    const exponent = (binary & 0x7c00) >> 10;\r\n    const fraction = binary & 0x03ff;\r\n\r\n    return (\r\n        (binary >> 15 ? -1 : 1) *\r\n        (exponent ? (exponent === 0x1f ? (fraction ? NaN : Infinity) : Math.pow(2, exponent - 15) * (1 + fraction / 0x400)) : 6.103515625e-5 * (fraction / 0x400))\r\n    );\r\n}\r\n\r\nfunction ToHalfFloat(value: number) {\r\n    if (Math.abs(value) > 65504) {\r\n        throw new Error(\"Value out of range.Consider using float instead of half-float.\");\r\n    }\r\n\r\n    value = Clamp(value, -65504, 65504);\r\n\r\n    _tables.floatView[0] = value;\r\n    const f = _tables.uint32View[0];\r\n    const e = (f >> 23) & 0x1ff;\r\n    return _tables.baseTable[e] + ((f & 0x007fffff) >> _tables.shiftTable[e]);\r\n}\r\n\r\n/**\r\n * Decode a float32 from the buffer\r\n * @param dataView dataview on the data\r\n * @param offset current offset in the data view\r\n * @returns a float32\r\n */\r\nexport function DecodeFloat32(dataView: DataView, offset: DataCursor) {\r\n    return ToHalfFloat(ParseFloat32(dataView, offset));\r\n}\r\n\r\nfunction ParseFixedLengthString(buffer: ArrayBuffer, offset: DataCursor, size: number) {\r\n    const stringValue = new TextDecoder().decode(new Uint8Array(buffer).slice(offset.value, offset.value + size));\r\n\r\n    offset.value = offset.value + size;\r\n\r\n    return stringValue;\r\n}\r\n\r\nfunction ParseRational(dataView: DataView, offset: DataCursor) {\r\n    const x = ParseInt32(dataView, offset);\r\n    const y = ParseUint32(dataView, offset);\r\n\r\n    return [x, y];\r\n}\r\n\r\nfunction ParseTimecode(dataView: DataView, offset: DataCursor) {\r\n    const x = ParseUint32(dataView, offset);\r\n    const y = ParseUint32(dataView, offset);\r\n\r\n    return [x, y];\r\n}\r\n\r\nfunction ParseV2f(dataView: DataView, offset: DataCursor) {\r\n    const x = ParseFloat32(dataView, offset);\r\n    const y = ParseFloat32(dataView, offset);\r\n\r\n    return [x, y];\r\n}\r\n\r\nfunction ParseV3f(dataView: DataView, offset: DataCursor) {\r\n    const x = ParseFloat32(dataView, offset);\r\n    const y = ParseFloat32(dataView, offset);\r\n    const z = ParseFloat32(dataView, offset);\r\n\r\n    return [x, y, z];\r\n}\r\n\r\nfunction ParseChlist(dataView: DataView, offset: DataCursor, size: number) {\r\n    const startOffset = offset.value;\r\n    const channels = [];\r\n\r\n    while (offset.value < startOffset + size - 1) {\r\n        const name = ParseNullTerminatedString(dataView.buffer, offset);\r\n        const pixelType = ParseInt32(dataView, offset);\r\n        const pLinear = ParseUint8(dataView, offset);\r\n        offset.value += 3; // reserved, three chars\r\n        const xSampling = ParseInt32(dataView, offset);\r\n        const ySampling = ParseInt32(dataView, offset);\r\n\r\n        channels.push({\r\n            name: name,\r\n            pixelType: pixelType,\r\n            pLinear: pLinear,\r\n            xSampling: xSampling,\r\n            ySampling: ySampling,\r\n        });\r\n    }\r\n\r\n    offset.value += 1;\r\n\r\n    return channels;\r\n}\r\n\r\nfunction ParseChromaticities(dataView: DataView, offset: DataCursor) {\r\n    const redX = ParseFloat32(dataView, offset);\r\n    const redY = ParseFloat32(dataView, offset);\r\n    const greenX = ParseFloat32(dataView, offset);\r\n    const greenY = ParseFloat32(dataView, offset);\r\n    const blueX = ParseFloat32(dataView, offset);\r\n    const blueY = ParseFloat32(dataView, offset);\r\n    const whiteX = ParseFloat32(dataView, offset);\r\n    const whiteY = ParseFloat32(dataView, offset);\r\n\r\n    return { redX: redX, redY: redY, greenX: greenX, greenY: greenY, blueX: blueX, blueY: blueY, whiteX: whiteX, whiteY: whiteY };\r\n}\r\n\r\nfunction ParseCompression(dataView: DataView, offset: DataCursor) {\r\n    return ParseUint8(dataView, offset);\r\n}\r\n\r\nfunction ParseBox2i(dataView: DataView, offset: DataCursor) {\r\n    const xMin = ParseInt32(dataView, offset);\r\n    const yMin = ParseInt32(dataView, offset);\r\n    const xMax = ParseInt32(dataView, offset);\r\n    const yMax = ParseInt32(dataView, offset);\r\n\r\n    return { xMin: xMin, yMin: yMin, xMax: xMax, yMax: yMax };\r\n}\r\n\r\nfunction ParseLineOrder(dataView: DataView, offset: DataCursor) {\r\n    const lineOrder = ParseUint8(dataView, offset);\r\n\r\n    return LineOrders[lineOrder];\r\n}\r\n\r\n/**\r\n * Parse a value from the data view\r\n * @param dataView defines the data view to read from\r\n * @param offset defines the current offset in the data view\r\n * @param type defines the type of the value to read\r\n * @param size defines the size of the value to read\r\n * @returns the parsed value\r\n */\r\nexport function ParseValue(dataView: DataView, offset: DataCursor, type: string, size: number) {\r\n    switch (type) {\r\n        case \"string\":\r\n        case \"stringvector\":\r\n        case \"iccProfile\":\r\n            return ParseFixedLengthString(dataView.buffer, offset, size);\r\n        case \"chlist\":\r\n            return ParseChlist(dataView, offset, size);\r\n        case \"chromaticities\":\r\n            return ParseChromaticities(dataView, offset);\r\n        case \"compression\":\r\n            return ParseCompression(dataView, offset);\r\n        case \"box2i\":\r\n            return ParseBox2i(dataView, offset);\r\n        case \"lineOrder\":\r\n            return ParseLineOrder(dataView, offset);\r\n        case \"float\":\r\n            return ParseFloat32(dataView, offset);\r\n        case \"v2f\":\r\n            return ParseV2f(dataView, offset);\r\n        case \"v3f\":\r\n            return ParseV3f(dataView, offset);\r\n        case \"int\":\r\n            return ParseInt32(dataView, offset);\r\n        case \"rational\":\r\n            return ParseRational(dataView, offset);\r\n        case \"timecode\":\r\n            return ParseTimecode(dataView, offset);\r\n        case \"preview\":\r\n            offset.value += size;\r\n            return \"skipped\";\r\n        default:\r\n            offset.value += size;\r\n            return undefined;\r\n    }\r\n}\r\n\r\n/**\r\n * Revert the endianness of the data\r\n * @param source defines the source\r\n */\r\nexport function Predictor(source: Uint8Array) {\r\n    for (let t = 1; t < source.length; t++) {\r\n        const d = source[t - 1] + source[t] - 128;\r\n        source[t] = d;\r\n    }\r\n}\r\n\r\n/**\r\n * Interleave pixels\r\n * @param source defines the data source\r\n * @param out defines the output\r\n */\r\nexport function InterleaveScalar(source: Uint8Array, out: Uint8Array) {\r\n    let t1 = 0;\r\n    let t2 = Math.floor((source.length + 1) / 2);\r\n    let s = 0;\r\n    const stop = source.length - 1;\r\n\r\n    // eslint-disable-next-line no-constant-condition\r\n    while (true) {\r\n        if (s > stop) {\r\n            break;\r\n        }\r\n        out[s++] = source[t1++];\r\n\r\n        if (s > stop) {\r\n            break;\r\n        }\r\n        out[s++] = source[t2++];\r\n    }\r\n}\r\n","/* eslint-disable @typescript-eslint/naming-convention */\r\nimport type { Nullable } from \"core/types\";\r\nimport type { DataCursor } from \"./exrLoader.core\";\r\nimport { ParseUint32, ParseUint8Array } from \"./exrLoader.core\";\r\nimport { HUF_DECBITS, HUF_DECMASK, HUF_DECSIZE, HUF_ENCSIZE, LONG_ZEROCODE_RUN, SHORT_ZEROCODE_RUN, SHORTEST_LONG_RUN, USHORT_RANGE } from \"./exrLoader.interfaces\";\r\n\r\n/**\r\n * Inspired by https://github.com/sciecode/three.js/blob/dev/examples/jsm/loaders/EXRLoader.js\r\n * Referred to the original Industrial Light & Magic OpenEXR implementation and the TinyEXR / Syoyo Fujita\r\n * implementation.\r\n */\r\n\r\n// /*\r\n// Copyright (c) 2014 - 2017, Syoyo Fujita\r\n// All rights reserved.\r\n\r\n// Redistribution and use in source and binary forms, with or without\r\n// modification, are permitted provided that the following conditions are met:\r\n//     * Redistributions of source code must retain the above copyright\r\n//       notice, this list of conditions and the following disclaimer.\r\n//     * Redistributions in binary form must reproduce the above copyright\r\n//       notice, this list of conditions and the following disclaimer in the\r\n//       documentation and/or other materials provided with the distribution.\r\n//     * Neither the name of the Syoyo Fujita nor the\r\n//       names of its contributors may be used to endorse or promote products\r\n//       derived from this software without specific prior written permission.\r\n\r\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\r\n// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\r\n// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\r\n// DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY\r\n// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\r\n// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\r\n// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\r\n// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\r\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\r\n// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\r\n// */\r\n\r\n// // TinyEXR contains some OpenEXR code, which is licensed under ------------\r\n\r\n// ///////////////////////////////////////////////////////////////////////////\r\n// //\r\n// // Copyright (c) 2002, Industrial Light & Magic, a division of Lucas\r\n// // Digital Ltd. LLC\r\n// //\r\n// // All rights reserved.\r\n// //\r\n// // Redistribution and use in source and binary forms, with or without\r\n// // modification, are permitted provided that the following conditions are\r\n// // met:\r\n// // *       Redistributions of source code must retain the above copyright\r\n// // notice, this list of conditions and the following disclaimer.\r\n// // *       Redistributions in binary form must reproduce the above\r\n// // copyright notice, this list of conditions and the following disclaimer\r\n// // in the documentation and/or other materials provided with the\r\n// // distribution.\r\n// // *       Neither the name of Industrial Light & Magic nor the names of\r\n// // its contributors may be used to endorse or promote products derived\r\n// // from this software without specific prior written permission.\r\n// //\r\n// // THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\r\n// // \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\r\n// // LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\r\n// // A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\r\n// // OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\r\n// // SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\r\n// // LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\r\n// // DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\r\n// // THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\r\n// // (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\r\n// // OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\r\n// //\r\n// ///////////////////////////////////////////////////////////////////////////\r\n\r\n// // End of OpenEXR license -------------------------------------------------\r\n\r\nconst NBITS = 16;\r\nconst A_OFFSET = 1 << (NBITS - 1);\r\nconst MOD_MASK = (1 << NBITS) - 1;\r\n\r\ninterface IGetBits {\r\n    l: number;\r\n    c: number;\r\n    lc: number;\r\n}\r\n\r\ninterface IGetChar {\r\n    c: number;\r\n    lc: number;\r\n}\r\n\r\n/** @internal */\r\nexport function ReverseLutFromBitmap(bitmap: Uint8Array, lut: Uint16Array) {\r\n    let k = 0;\r\n\r\n    for (let i = 0; i < USHORT_RANGE; ++i) {\r\n        if (i == 0 || bitmap[i >> 3] & (1 << (i & 7))) {\r\n            lut[k++] = i;\r\n        }\r\n    }\r\n\r\n    const n = k - 1;\r\n\r\n    while (k < USHORT_RANGE) lut[k++] = 0;\r\n\r\n    return n;\r\n}\r\n\r\nfunction HufClearDecTable(hdec: Array<any>) {\r\n    for (let i = 0; i < HUF_DECSIZE; i++) {\r\n        hdec[i] = {};\r\n        hdec[i].len = 0;\r\n        hdec[i].lit = 0;\r\n        hdec[i].p = null;\r\n    }\r\n}\r\n\r\nfunction GetBits(nBits: number, c: number, lc: number, array: Uint8Array, offset: DataCursor): IGetBits {\r\n    while (lc < nBits) {\r\n        c = (c << 8) | ParseUint8Array(array, offset);\r\n        lc += 8;\r\n    }\r\n\r\n    lc -= nBits;\r\n\r\n    return {\r\n        l: (c >> lc) & ((1 << nBits) - 1),\r\n        c,\r\n        lc,\r\n    };\r\n}\r\n\r\nfunction GetChar(c: number, lc: number, array: Uint8Array, offset: DataCursor): IGetChar {\r\n    c = (c << 8) | ParseUint8Array(array, offset);\r\n    lc += 8;\r\n\r\n    return {\r\n        c,\r\n        lc,\r\n    };\r\n}\r\n\r\nfunction GetCode(\r\n    po: number,\r\n    rlc: number,\r\n    c: number,\r\n    lc: number,\r\n    array: Uint8Array,\r\n    offset: DataCursor,\r\n    outBuffer: Uint16Array,\r\n    outBufferOffset: DataCursor,\r\n    outBufferEndOffset: number\r\n): Nullable<IGetChar> {\r\n    if (po == rlc) {\r\n        if (lc < 8) {\r\n            const gc = GetChar(c, lc, array, offset);\r\n            c = gc.c;\r\n            lc = gc.lc;\r\n        }\r\n\r\n        lc -= 8;\r\n\r\n        let cs = c >> lc;\r\n        cs = new Uint8Array([cs])[0];\r\n\r\n        if (outBufferOffset.value + cs > outBufferEndOffset) {\r\n            return null;\r\n        }\r\n\r\n        const s = outBuffer[outBufferOffset.value - 1];\r\n\r\n        while (cs-- > 0) {\r\n            outBuffer[outBufferOffset.value++] = s;\r\n        }\r\n    } else if (outBufferOffset.value < outBufferEndOffset) {\r\n        outBuffer[outBufferOffset.value++] = po;\r\n    } else {\r\n        return null;\r\n    }\r\n\r\n    return { c, lc };\r\n}\r\n\r\nconst HufTableBuffer = new Array(59);\r\n\r\nfunction HufCanonicalCodeTable(hcode: Array<any>) {\r\n    for (let i = 0; i <= 58; ++i) HufTableBuffer[i] = 0;\r\n    for (let i = 0; i < HUF_ENCSIZE; ++i) HufTableBuffer[hcode[i]] += 1;\r\n\r\n    let c = 0;\r\n\r\n    for (let i = 58; i > 0; --i) {\r\n        const nc = (c + HufTableBuffer[i]) >> 1;\r\n        HufTableBuffer[i] = c;\r\n        c = nc;\r\n    }\r\n\r\n    for (let i = 0; i < HUF_ENCSIZE; ++i) {\r\n        const l = hcode[i];\r\n        if (l > 0) hcode[i] = l | (HufTableBuffer[l]++ << 6);\r\n    }\r\n}\r\n\r\nfunction HufUnpackEncTable(array: Uint8Array, offset: DataCursor, ni: number, im: number, iM: number, hcode: Array<any>) {\r\n    const p = offset;\r\n    let c = 0;\r\n    let lc = 0;\r\n\r\n    for (; im <= iM; im++) {\r\n        if (p.value - offset.value > ni) {\r\n            return;\r\n        }\r\n\r\n        let gb = GetBits(6, c, lc, array, p);\r\n\r\n        const l = gb.l;\r\n        c = gb.c;\r\n        lc = gb.lc;\r\n\r\n        hcode[im] = l;\r\n\r\n        if (l == LONG_ZEROCODE_RUN) {\r\n            if (p.value - offset.value > ni) {\r\n                throw new Error(\"Error in HufUnpackEncTable\");\r\n            }\r\n\r\n            gb = GetBits(8, c, lc, array, p);\r\n\r\n            let zerun = gb.l + SHORTEST_LONG_RUN;\r\n            c = gb.c;\r\n            lc = gb.lc;\r\n\r\n            if (im + zerun > iM + 1) {\r\n                throw new Error(\"Error in HufUnpackEncTable\");\r\n            }\r\n\r\n            while (zerun--) hcode[im++] = 0;\r\n\r\n            im--;\r\n        } else if (l >= SHORT_ZEROCODE_RUN) {\r\n            let zerun = l - SHORT_ZEROCODE_RUN + 2;\r\n\r\n            if (im + zerun > iM + 1) {\r\n                throw new Error(\"Error in HufUnpackEncTable\");\r\n            }\r\n\r\n            while (zerun--) hcode[im++] = 0;\r\n\r\n            im--;\r\n        }\r\n    }\r\n\r\n    HufCanonicalCodeTable(hcode);\r\n}\r\n\r\nfunction HufLength(code: number) {\r\n    return code & 63;\r\n}\r\n\r\nfunction HufCode(code: number) {\r\n    return code >> 6;\r\n}\r\n\r\nfunction HufBuildDecTable(hcode: Array<any>, im: number, iM: number, hdecod: Array<any>) {\r\n    for (; im <= iM; im++) {\r\n        const c = HufCode(hcode[im]);\r\n        const l = HufLength(hcode[im]);\r\n\r\n        if (c >> l) {\r\n            throw new Error(\"Invalid table entry\");\r\n        }\r\n\r\n        if (l > HUF_DECBITS) {\r\n            const pl = hdecod[c >> (l - HUF_DECBITS)];\r\n\r\n            if (pl.len) {\r\n                throw new Error(\"Invalid table entry\");\r\n            }\r\n\r\n            pl.lit++;\r\n\r\n            if (pl.p) {\r\n                const p = pl.p;\r\n                pl.p = new Array(pl.lit);\r\n\r\n                for (let i = 0; i < pl.lit - 1; ++i) {\r\n                    pl.p[i] = p[i];\r\n                }\r\n            } else {\r\n                pl.p = new Array(1);\r\n            }\r\n\r\n            pl.p[pl.lit - 1] = im;\r\n        } else if (l) {\r\n            let plOffset = 0;\r\n\r\n            for (let i = 1 << (HUF_DECBITS - l); i > 0; i--) {\r\n                const pl = hdecod[(c << (HUF_DECBITS - l)) + plOffset];\r\n\r\n                if (pl.len || pl.p) {\r\n                    throw new Error(\"Invalid table entry\");\r\n                }\r\n\r\n                pl.len = l;\r\n                pl.lit = im;\r\n\r\n                plOffset++;\r\n            }\r\n        }\r\n    }\r\n\r\n    return true;\r\n}\r\n\r\nfunction HufDecode(\r\n    encodingTable: Array<any>,\r\n    decodingTable: Array<any>,\r\n    array: Uint8Array,\r\n    offset: DataCursor,\r\n    ni: number,\r\n    rlc: number,\r\n    no: number,\r\n    outBuffer: Uint16Array,\r\n    outOffset: DataCursor\r\n) {\r\n    let c = 0;\r\n    let lc = 0;\r\n    const outBufferEndOffset = no;\r\n    const inOffsetEnd = Math.trunc(offset.value + (ni + 7) / 8);\r\n\r\n    while (offset.value < inOffsetEnd) {\r\n        let gc = GetChar(c, lc, array, offset);\r\n\r\n        c = gc.c;\r\n        lc = gc.lc;\r\n\r\n        while (lc >= HUF_DECBITS) {\r\n            const index = (c >> (lc - HUF_DECBITS)) & HUF_DECMASK;\r\n            const pl = decodingTable[index];\r\n\r\n            if (pl.len) {\r\n                lc -= pl.len;\r\n\r\n                const gCode = GetCode(pl.lit, rlc, c, lc, array, offset, outBuffer, outOffset, outBufferEndOffset);\r\n                if (gCode) {\r\n                    c = gCode.c;\r\n                    lc = gCode.lc;\r\n                }\r\n            } else {\r\n                if (!pl.p) {\r\n                    throw new Error(\"hufDecode issues\");\r\n                }\r\n\r\n                let j;\r\n\r\n                for (j = 0; j < pl.lit; j++) {\r\n                    const l = HufLength(encodingTable[pl.p[j]]);\r\n\r\n                    while (lc < l && offset.value < inOffsetEnd) {\r\n                        gc = GetChar(c, lc, array, offset);\r\n\r\n                        c = gc.c;\r\n                        lc = gc.lc;\r\n                    }\r\n\r\n                    if (lc >= l) {\r\n                        if (HufCode(encodingTable[pl.p[j]]) == ((c >> (lc - l)) & ((1 << l) - 1))) {\r\n                            lc -= l;\r\n\r\n                            const gCode = GetCode(pl.p[j], rlc, c, lc, array, offset, outBuffer, outOffset, outBufferEndOffset);\r\n\r\n                            if (gCode) {\r\n                                c = gCode.c;\r\n                                lc = gCode.lc;\r\n                            }\r\n\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n\r\n                if (j == pl.lit) {\r\n                    throw new Error(\"HufDecode issues\");\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    const i = (8 - ni) & 7;\r\n\r\n    c >>= i;\r\n    lc -= i;\r\n\r\n    while (lc > 0) {\r\n        const pl = decodingTable[(c << (HUF_DECBITS - lc)) & HUF_DECMASK];\r\n\r\n        if (pl.len) {\r\n            lc -= pl.len;\r\n\r\n            const gCode = GetCode(pl.lit, rlc, c, lc, array, offset, outBuffer, outOffset, outBufferEndOffset);\r\n            if (gCode) {\r\n                c = gCode.c;\r\n                lc = gCode.lc;\r\n            }\r\n        } else {\r\n            throw new Error(\"HufDecode issues\");\r\n        }\r\n    }\r\n\r\n    return true;\r\n}\r\n\r\n/** @internal */\r\nexport function HufUncompress(array: Uint8Array, dataView: DataView, offset: DataCursor, nCompressed: number, outBuffer: Uint16Array, nRaw: number) {\r\n    const outOffset: DataCursor = { value: 0 };\r\n    const initialInOffset = offset.value;\r\n\r\n    const im = ParseUint32(dataView, offset);\r\n    const iM = ParseUint32(dataView, offset);\r\n\r\n    offset.value += 4;\r\n\r\n    const nBits = ParseUint32(dataView, offset);\r\n\r\n    offset.value += 4;\r\n\r\n    if (im < 0 || im >= HUF_ENCSIZE || iM < 0 || iM >= HUF_ENCSIZE) {\r\n        throw new Error(\"Wrong HUF_ENCSIZE\");\r\n    }\r\n\r\n    const freq = new Array(HUF_ENCSIZE);\r\n    const hdec = new Array(HUF_DECSIZE);\r\n\r\n    HufClearDecTable(hdec);\r\n\r\n    const ni = nCompressed - (offset.value - initialInOffset);\r\n\r\n    HufUnpackEncTable(array, offset, ni, im, iM, freq);\r\n\r\n    if (nBits > 8 * (nCompressed - (offset.value - initialInOffset))) {\r\n        throw new Error(\"Wrong hufUncompress\");\r\n    }\r\n\r\n    HufBuildDecTable(freq, im, iM, hdec);\r\n\r\n    HufDecode(freq, hdec, array, offset, nBits, iM, nRaw, outBuffer, outOffset);\r\n}\r\n\r\nfunction UInt16(value: number) {\r\n    return value & 0xffff;\r\n}\r\n\r\nfunction Int16(value: number) {\r\n    const ref = UInt16(value);\r\n    return ref > 0x7fff ? ref - 0x10000 : ref;\r\n}\r\n\r\nfunction Wdec14(l: number, h: number) {\r\n    const ls = Int16(l);\r\n    const hs = Int16(h);\r\n\r\n    const hi = hs;\r\n    const ai = ls + (hi & 1) + (hi >> 1);\r\n\r\n    const as = ai;\r\n    const bs = ai - hi;\r\n\r\n    return { a: as, b: bs };\r\n}\r\n\r\nfunction Wdec16(l: number, h: number) {\r\n    const m = UInt16(l);\r\n    const d = UInt16(h);\r\n\r\n    const bb = (m - (d >> 1)) & MOD_MASK;\r\n    const aa = (d + bb - A_OFFSET) & MOD_MASK;\r\n\r\n    return { a: aa, b: bb };\r\n}\r\n\r\n/** @internal */\r\nexport function Wav2Decode(buffer: Uint16Array, j: number, nx: number, ox: number, ny: number, oy: number, mx: number) {\r\n    const w14 = mx < 1 << 14;\r\n    const n = nx > ny ? ny : nx;\r\n    let p = 1;\r\n    let p2;\r\n    let py;\r\n\r\n    while (p <= n) p <<= 1;\r\n\r\n    p >>= 1;\r\n    p2 = p;\r\n    p >>= 1;\r\n\r\n    while (p >= 1) {\r\n        py = 0;\r\n        const ey = py + oy * (ny - p2);\r\n        const oy1 = oy * p;\r\n        const oy2 = oy * p2;\r\n        const ox1 = ox * p;\r\n        const ox2 = ox * p2;\r\n        let i00, i01, i10, i11;\r\n\r\n        for (; py <= ey; py += oy2) {\r\n            let px = py;\r\n            const ex = py + ox * (nx - p2);\r\n\r\n            for (; px <= ex; px += ox2) {\r\n                const p01 = px + ox1;\r\n                const p10 = px + oy1;\r\n                const p11 = p10 + ox1;\r\n\r\n                if (w14) {\r\n                    let result = Wdec14(buffer[px + j], buffer[p10 + j]);\r\n\r\n                    i00 = result.a;\r\n                    i10 = result.b;\r\n\r\n                    result = Wdec14(buffer[p01 + j], buffer[p11 + j]);\r\n\r\n                    i01 = result.a;\r\n                    i11 = result.b;\r\n\r\n                    result = Wdec14(i00, i01);\r\n\r\n                    buffer[px + j] = result.a;\r\n                    buffer[p01 + j] = result.b;\r\n\r\n                    result = Wdec14(i10, i11);\r\n\r\n                    buffer[p10 + j] = result.a;\r\n                    buffer[p11 + j] = result.b;\r\n                } else {\r\n                    let result = Wdec16(buffer[px + j], buffer[p10 + j]);\r\n\r\n                    i00 = result.a;\r\n                    i10 = result.b;\r\n\r\n                    result = Wdec16(buffer[p01 + j], buffer[p11 + j]);\r\n\r\n                    i01 = result.a;\r\n                    i11 = result.b;\r\n\r\n                    result = Wdec16(i00, i01);\r\n\r\n                    buffer[px + j] = result.a;\r\n                    buffer[p01 + j] = result.b;\r\n\r\n                    result = Wdec16(i10, i11);\r\n\r\n                    buffer[p10 + j] = result.a;\r\n                    buffer[p11 + j] = result.b;\r\n                }\r\n            }\r\n\r\n            if (nx & p) {\r\n                const p10 = px + oy1;\r\n                let result;\r\n                if (w14) {\r\n                    result = Wdec14(buffer[px + j], buffer[p10 + j]);\r\n                } else {\r\n                    result = Wdec16(buffer[px + j], buffer[p10 + j]);\r\n                }\r\n\r\n                i00 = result.a;\r\n                buffer[p10 + j] = result.b;\r\n\r\n                buffer[px + j] = i00;\r\n            }\r\n        }\r\n\r\n        if (ny & p) {\r\n            let px = py;\r\n            const ex = py + ox * (nx - p2);\r\n\r\n            for (; px <= ex; px += ox2) {\r\n                const p01 = px + ox1;\r\n                let result;\r\n\r\n                if (w14) {\r\n                    result = Wdec14(buffer[px + j], buffer[p01 + j]);\r\n                } else {\r\n                    result = Wdec16(buffer[px + j], buffer[p01 + j]);\r\n                }\r\n\r\n                i00 = result.a;\r\n                buffer[p01 + j] = result.b;\r\n\r\n                buffer[px + j] = i00;\r\n            }\r\n        }\r\n\r\n        p2 = p;\r\n        p >>= 1;\r\n    }\r\n\r\n    return py;\r\n}\r\n\r\n/** @internal */\r\nexport function ApplyLut(lut: Uint16Array, data: Uint16Array, nData: number) {\r\n    for (let i = 0; i < nData; ++i) {\r\n        data[i] = lut[data[i]];\r\n    }\r\n}\r\n","import { ApplyLut, HufUncompress, ReverseLutFromBitmap, Wav2Decode } from \"./exrLoader.compression.huf\";\r\nimport { DecodeRunLength } from \"./exrLoader.compression.rle\";\r\nimport { InterleaveScalar, ParseUint16, ParseUint32, ParseUint8, Predictor } from \"./exrLoader.core\";\r\nimport { BITMAP_SIZE, INT16_SIZE, USHORT_RANGE, type IEXRDecoder } from \"./exrLoader.interfaces\";\r\n\r\n/**\r\n * Inspired by https://github.com/sciecode/three.js/blob/dev/examples/jsm/loaders/EXRLoader.js\r\n * Referred to the original Industrial Light & Magic OpenEXR implementation and the TinyEXR / Syoyo Fujita\r\n * implementation.\r\n */\r\n\r\n// /*\r\n// Copyright (c) 2014 - 2017, Syoyo Fujita\r\n// All rights reserved.\r\n\r\n// Redistribution and use in source and binary forms, with or without\r\n// modification, are permitted provided that the following conditions are met:\r\n//     * Redistributions of source code must retain the above copyright\r\n//       notice, this list of conditions and the following disclaimer.\r\n//     * Redistributions in binary form must reproduce the above copyright\r\n//       notice, this list of conditions and the following disclaimer in the\r\n//       documentation and/or other materials provided with the distribution.\r\n//     * Neither the name of the Syoyo Fujita nor the\r\n//       names of its contributors may be used to endorse or promote products\r\n//       derived from this software without specific prior written permission.\r\n\r\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\r\n// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\r\n// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\r\n// DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY\r\n// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\r\n// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\r\n// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\r\n// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\r\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\r\n// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\r\n// */\r\n\r\n// // TinyEXR contains some OpenEXR code, which is licensed under ------------\r\n\r\n// ///////////////////////////////////////////////////////////////////////////\r\n// //\r\n// // Copyright (c) 2002, Industrial Light & Magic, a division of Lucas\r\n// // Digital Ltd. LLC\r\n// //\r\n// // All rights reserved.\r\n// //\r\n// // Redistribution and use in source and binary forms, with or without\r\n// // modification, are permitted provided that the following conditions are\r\n// // met:\r\n// // *       Redistributions of source code must retain the above copyright\r\n// // notice, this list of conditions and the following disclaimer.\r\n// // *       Redistributions in binary form must reproduce the above\r\n// // copyright notice, this list of conditions and the following disclaimer\r\n// // in the documentation and/or other materials provided with the\r\n// // distribution.\r\n// // *       Neither the name of Industrial Light & Magic nor the names of\r\n// // its contributors may be used to endorse or promote products derived\r\n// // from this software without specific prior written permission.\r\n// //\r\n// // THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\r\n// // \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\r\n// // LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\r\n// // A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\r\n// // OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\r\n// // SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\r\n// // LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\r\n// // DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\r\n// // THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\r\n// // (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\r\n// // OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\r\n// //\r\n// ///////////////////////////////////////////////////////////////////////////\r\n\r\n// // End of OpenEXR license -------------------------------------------------\r\n\r\n// FFlate access\r\ndeclare const fflate: any;\r\n\r\n/**\r\n * No compression\r\n * @param decoder defines the decoder to use\r\n * @returns a decompressed data view\r\n */\r\nexport function UncompressRAW(decoder: IEXRDecoder): DataView {\r\n    return new DataView(decoder.array.buffer, decoder.offset.value, decoder.size);\r\n}\r\n\r\n/**\r\n * RLE compression\r\n * @param decoder defines the decoder to use\r\n * @returns a decompressed data view\r\n */\r\nexport function UncompressRLE(decoder: IEXRDecoder): DataView {\r\n    const compressed = decoder.viewer.buffer.slice(decoder.offset.value, decoder.offset.value + decoder.size);\r\n\r\n    const rawBuffer = new Uint8Array(DecodeRunLength(compressed));\r\n    const tmpBuffer = new Uint8Array(rawBuffer.length);\r\n\r\n    Predictor(rawBuffer);\r\n\r\n    InterleaveScalar(rawBuffer, tmpBuffer);\r\n\r\n    return new DataView(tmpBuffer.buffer);\r\n}\r\n\r\n/**\r\n * Zip compression\r\n * @param decoder defines the decoder to use\r\n * @returns a decompressed data view\r\n */\r\nexport function UncompressZIP(decoder: IEXRDecoder): DataView {\r\n    const compressed = decoder.array.slice(decoder.offset.value, decoder.offset.value + decoder.size);\r\n\r\n    const rawBuffer = fflate.unzlibSync(compressed);\r\n    const tmpBuffer = new Uint8Array(rawBuffer.length);\r\n\r\n    Predictor(rawBuffer);\r\n\r\n    InterleaveScalar(rawBuffer, tmpBuffer);\r\n\r\n    return new DataView(tmpBuffer.buffer);\r\n}\r\n\r\n/**\r\n * PXR compression\r\n * @param decoder defines the decoder to use\r\n * @returns a decompressed data view\r\n */\r\nexport function UncompressPXR(decoder: IEXRDecoder): DataView {\r\n    const compressed = decoder.array.slice(decoder.offset.value, decoder.offset.value + decoder.size);\r\n\r\n    const rawBuffer = fflate.unzlibSync(compressed);\r\n\r\n    const sz = decoder.lines * decoder.channels * decoder.width;\r\n    const tmpBuffer = decoder.type == 1 ? new Uint16Array(sz) : new Uint32Array(sz);\r\n\r\n    let tmpBufferEnd = 0;\r\n    let writePtr = 0;\r\n    const ptr = new Array(4);\r\n\r\n    for (let y = 0; y < decoder.lines; y++) {\r\n        for (let c = 0; c < decoder.channels; c++) {\r\n            let pixel = 0;\r\n\r\n            switch (decoder.type) {\r\n                case 1:\r\n                    ptr[0] = tmpBufferEnd;\r\n                    ptr[1] = ptr[0] + decoder.width;\r\n                    tmpBufferEnd = ptr[1] + decoder.width;\r\n\r\n                    for (let j = 0; j < decoder.width; ++j) {\r\n                        const diff = (rawBuffer[ptr[0]++] << 8) | rawBuffer[ptr[1]++];\r\n\r\n                        pixel += diff;\r\n\r\n                        tmpBuffer[writePtr] = pixel;\r\n                        writePtr++;\r\n                    }\r\n\r\n                    break;\r\n\r\n                case 2:\r\n                    ptr[0] = tmpBufferEnd;\r\n                    ptr[1] = ptr[0] + decoder.width;\r\n                    ptr[2] = ptr[1] + decoder.width;\r\n                    tmpBufferEnd = ptr[2] + decoder.width;\r\n\r\n                    for (let j = 0; j < decoder.width; ++j) {\r\n                        const diff = (rawBuffer[ptr[0]++] << 24) | (rawBuffer[ptr[1]++] << 16) | (rawBuffer[ptr[2]++] << 8);\r\n\r\n                        pixel += diff;\r\n\r\n                        tmpBuffer[writePtr] = pixel;\r\n                        writePtr++;\r\n                    }\r\n\r\n                    break;\r\n            }\r\n        }\r\n    }\r\n\r\n    return new DataView(tmpBuffer.buffer);\r\n}\r\n\r\n/**\r\n * PIZ compression\r\n * @param decoder defines the decoder to use\r\n * @returns a decompressed data view\r\n */\r\nexport function UncompressPIZ(decoder: IEXRDecoder): DataView {\r\n    const inDataView = decoder.viewer;\r\n    const inOffset = { value: decoder.offset.value };\r\n\r\n    const outBuffer = new Uint16Array(decoder.width * decoder.scanlineBlockSize * (decoder.channels * decoder.type));\r\n    const bitmap = new Uint8Array(BITMAP_SIZE);\r\n\r\n    // Setup channel info\r\n    let outBufferEnd = 0;\r\n    const pizChannelData = new Array(decoder.channels);\r\n    for (let i = 0; i < decoder.channels; i++) {\r\n        pizChannelData[i] = {};\r\n        pizChannelData[i][\"start\"] = outBufferEnd;\r\n        pizChannelData[i][\"end\"] = pizChannelData[i][\"start\"];\r\n        pizChannelData[i][\"nx\"] = decoder.width;\r\n        pizChannelData[i][\"ny\"] = decoder.lines;\r\n        pizChannelData[i][\"size\"] = decoder.type;\r\n\r\n        outBufferEnd += pizChannelData[i].nx * pizChannelData[i].ny * pizChannelData[i].size;\r\n    }\r\n\r\n    // Read range compression data\r\n    const minNonZero = ParseUint16(inDataView, inOffset);\r\n    const maxNonZero = ParseUint16(inDataView, inOffset);\r\n\r\n    if (maxNonZero >= BITMAP_SIZE) {\r\n        throw new Error(\"Wrong PIZ_COMPRESSION BITMAP_SIZE\");\r\n    }\r\n\r\n    if (minNonZero <= maxNonZero) {\r\n        for (let i = 0; i < maxNonZero - minNonZero + 1; i++) {\r\n            bitmap[i + minNonZero] = ParseUint8(inDataView, inOffset);\r\n        }\r\n    }\r\n\r\n    // Reverse LUT\r\n    const lut = new Uint16Array(USHORT_RANGE);\r\n    const maxValue = ReverseLutFromBitmap(bitmap, lut);\r\n\r\n    const length = ParseUint32(inDataView, inOffset);\r\n\r\n    // Huffman decoding\r\n    HufUncompress(decoder.array, inDataView, inOffset, length, outBuffer, outBufferEnd);\r\n\r\n    // Wavelet decoding\r\n    for (let i = 0; i < decoder.channels; ++i) {\r\n        const cd = pizChannelData[i];\r\n\r\n        for (let j = 0; j < pizChannelData[i].size; ++j) {\r\n            Wav2Decode(outBuffer, cd.start + j, cd.nx, cd.size, cd.ny, cd.nx * cd.size, maxValue);\r\n        }\r\n    }\r\n\r\n    // Expand the pixel data to their original range\r\n    ApplyLut(lut, outBuffer, outBufferEnd);\r\n\r\n    // Rearrange the pixel data into the format expected by the caller.\r\n    let tmpOffset = 0;\r\n    const tmpBuffer = new Uint8Array(outBuffer.buffer.byteLength);\r\n    for (let y = 0; y < decoder.lines; y++) {\r\n        for (let c = 0; c < decoder.channels; c++) {\r\n            const cd = pizChannelData[c];\r\n\r\n            const n = cd.nx * cd.size;\r\n            const cp = new Uint8Array(outBuffer.buffer, cd.end * INT16_SIZE, n * INT16_SIZE);\r\n\r\n            tmpBuffer.set(cp, tmpOffset);\r\n            tmpOffset += n * INT16_SIZE;\r\n            cd.end += n;\r\n        }\r\n    }\r\n\r\n    return new DataView(tmpBuffer.buffer);\r\n}\r\n","/**\r\n * Inspired by https://github.com/sciecode/three.js/blob/dev/examples/jsm/loaders/EXRLoader.js\r\n * Referred to the original Industrial Light & Magic OpenEXR implementation and the TinyEXR / Syoyo Fujita\r\n * implementation.\r\n */\r\n\r\n// /*\r\n// Copyright (c) 2014 - 2017, Syoyo Fujita\r\n// All rights reserved.\r\n\r\n// Redistribution and use in source and binary forms, with or without\r\n// modification, are permitted provided that the following conditions are met:\r\n//     * Redistributions of source code must retain the above copyright\r\n//       notice, this list of conditions and the following disclaimer.\r\n//     * Redistributions in binary form must reproduce the above copyright\r\n//       notice, this list of conditions and the following disclaimer in the\r\n//       documentation and/or other materials provided with the distribution.\r\n//     * Neither the name of the Syoyo Fujita nor the\r\n//       names of its contributors may be used to endorse or promote products\r\n//       derived from this software without specific prior written permission.\r\n\r\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\r\n// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\r\n// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\r\n// DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY\r\n// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\r\n// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\r\n// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\r\n// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\r\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\r\n// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\r\n// */\r\n\r\n// // TinyEXR contains some OpenEXR code, which is licensed under ------------\r\n\r\n// ///////////////////////////////////////////////////////////////////////////\r\n// //\r\n// // Copyright (c) 2002, Industrial Light & Magic, a division of Lucas\r\n// // Digital Ltd. LLC\r\n// //\r\n// // All rights reserved.\r\n// //\r\n// // Redistribution and use in source and binary forms, with or without\r\n// // modification, are permitted provided that the following conditions are\r\n// // met:\r\n// // *       Redistributions of source code must retain the above copyright\r\n// // notice, this list of conditions and the following disclaimer.\r\n// // *       Redistributions in binary form must reproduce the above\r\n// // copyright notice, this list of conditions and the following disclaimer\r\n// // in the documentation and/or other materials provided with the\r\n// // distribution.\r\n// // *       Neither the name of Industrial Light & Magic nor the names of\r\n// // its contributors may be used to endorse or promote products derived\r\n// // from this software without specific prior written permission.\r\n// //\r\n// // THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\r\n// // \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\r\n// // LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\r\n// // A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\r\n// // OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\r\n// // SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\r\n// // LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\r\n// // DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\r\n// // THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\r\n// // (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\r\n// // OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\r\n// //\r\n// ///////////////////////////////////////////////////////////////////////////\r\n\r\n// // End of OpenEXR license -------------------------------------------------\r\n\r\n/** @internal */\r\nexport function DecodeRunLength(source: ArrayBuffer) {\r\n    let size = source.byteLength;\r\n    const out = new Array();\r\n    let p = 0;\r\n\r\n    const reader = new DataView(source);\r\n\r\n    while (size > 0) {\r\n        const l = reader.getInt8(p++);\r\n\r\n        if (l < 0) {\r\n            const count = -l;\r\n            size -= count + 1;\r\n\r\n            for (let i = 0; i < count; i++) {\r\n                out.push(reader.getUint8(p++));\r\n            }\r\n        } else {\r\n            const count = l;\r\n            size -= 2;\r\n\r\n            const value = reader.getUint8(p++);\r\n\r\n            for (let i = 0; i < count + 1; i++) {\r\n                out.push(value);\r\n            }\r\n        }\r\n    }\r\n\r\n    return out;\r\n}\r\n","export enum EXROutputType {\r\n    Float = 0,\r\n    HalfFloat = 1,\r\n}\r\n\r\n/**\r\n * Class used to store configuration of the exr loader\r\n */\r\nexport class ExrLoaderGlobalConfiguration {\r\n    /**\r\n     * Defines the default output type to use (Half float by default)\r\n     */\r\n    public static DefaultOutputType: EXROutputType = EXROutputType.HalfFloat;\r\n    /**\r\n     * Url to use to load the fflate library (for zip decompression)\r\n     */\r\n    public static FFLATEUrl = \"https://unpkg.com/fflate@0.8.2\";\r\n}\r\n","import type { Nullable } from \"core/types\";\r\nimport type { InternalTexture } from \"../internalTexture\";\r\nimport type { IInternalTextureLoader } from \"./internalTextureLoader\";\r\nimport { GetExrHeader } from \"./EXR/exrLoader.header\";\r\nimport { CreateDecoderAsync, ScanData } from \"./EXR/exrLoader.decoder\";\r\nimport { ExrLoaderGlobalConfiguration } from \"./EXR/exrLoader.configuration\";\r\n\r\n/**\r\n * Inspired by https://github.com/sciecode/three.js/blob/dev/examples/jsm/loaders/EXRLoader.js\r\n * Referred to the original Industrial Light & Magic OpenEXR implementation and the TinyEXR / Syoyo Fujita\r\n * implementation.\r\n */\r\n\r\n// /*\r\n// Copyright (c) 2014 - 2017, Syoyo Fujita\r\n// All rights reserved.\r\n\r\n// Redistribution and use in source and binary forms, with or without\r\n// modification, are permitted provided that the following conditions are met:\r\n//     * Redistributions of source code must retain the above copyright\r\n//       notice, this list of conditions and the following disclaimer.\r\n//     * Redistributions in binary form must reproduce the above copyright\r\n//       notice, this list of conditions and the following disclaimer in the\r\n//       documentation and/or other materials provided with the distribution.\r\n//     * Neither the name of the Syoyo Fujita nor the\r\n//       names of its contributors may be used to endorse or promote products\r\n//       derived from this software without specific prior written permission.\r\n\r\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\r\n// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\r\n// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\r\n// DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY\r\n// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\r\n// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\r\n// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\r\n// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\r\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\r\n// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\r\n// */\r\n\r\n// // TinyEXR contains some OpenEXR code, which is licensed under ------------\r\n\r\n// ///////////////////////////////////////////////////////////////////////////\r\n// //\r\n// // Copyright (c) 2002, Industrial Light & Magic, a division of Lucas\r\n// // Digital Ltd. LLC\r\n// //\r\n// // All rights reserved.\r\n// //\r\n// // Redistribution and use in source and binary forms, with or without\r\n// // modification, are permitted provided that the following conditions are\r\n// // met:\r\n// // *       Redistributions of source code must retain the above copyright\r\n// // notice, this list of conditions and the following disclaimer.\r\n// // *       Redistributions in binary form must reproduce the above\r\n// // copyright notice, this list of conditions and the following disclaimer\r\n// // in the documentation and/or other materials provided with the\r\n// // distribution.\r\n// // *       Neither the name of Industrial Light & Magic nor the names of\r\n// // its contributors may be used to endorse or promote products derived\r\n// // from this software without specific prior written permission.\r\n// //\r\n// // THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\r\n// // \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\r\n// // LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\r\n// // A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\r\n// // OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\r\n// // SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\r\n// // LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\r\n// // DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\r\n// // THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\r\n// // (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\r\n// // OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\r\n// //\r\n// ///////////////////////////////////////////////////////////////////////////\r\n\r\n// // End of OpenEXR license -------------------------------------------------\r\n\r\n/**\r\n * Loader for .exr file format\r\n * #4RN0VF#151: PIZ compression\r\n * #4RN0VF#146: ZIP compression\r\n * #4RN0VF#149: RLE compression\r\n * #4RN0VF#150: PXR24 compression\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport class _ExrTextureLoader implements IInternalTextureLoader {\r\n    /**\r\n     * Defines whether the loader supports cascade loading the different faces.\r\n     */\r\n    public readonly supportCascades = false;\r\n\r\n    /**\r\n     * Uploads the cube texture data to the WebGL texture. It has already been bound.\r\n     * @param _data contains the texture data\r\n     * @param _texture defines the BabylonJS internal texture\r\n     * @param _createPolynomials will be true if polynomials have been requested\r\n     * @param _onLoad defines the callback to trigger once the texture is ready\r\n     * @param _onError defines the callback to trigger in case of error\r\n     */\r\n    public loadCubeData(\r\n        _data: ArrayBufferView | ArrayBufferView[],\r\n        _texture: InternalTexture,\r\n        _createPolynomials: boolean,\r\n        _onLoad: Nullable<(data?: any) => void>,\r\n        _onError: Nullable<(message?: string, exception?: any) => void>\r\n    ): void {\r\n        // eslint-disable-next-line no-throw-literal\r\n        throw \".exr not supported in Cube.\";\r\n    }\r\n\r\n    /**\r\n     * Uploads the 2D texture data to the WebGL texture. It has already been bound once in the callback.\r\n     * @param data contains the texture data\r\n     * @param texture defines the BabylonJS internal texture\r\n     * @param callback defines the method to call once ready to upload\r\n     */\r\n    public async loadData(\r\n        data: ArrayBufferView,\r\n        texture: InternalTexture,\r\n        callback: (width: number, height: number, loadMipmap: boolean, isCompressed: boolean, done: () => void, failedLoading?: boolean) => void\r\n    ) {\r\n        const dataView = new DataView(data.buffer);\r\n\r\n        const offset = { value: 0 };\r\n        const header = GetExrHeader(dataView, offset);\r\n        const decoder = await CreateDecoderAsync(header, dataView, offset, ExrLoaderGlobalConfiguration.DefaultOutputType);\r\n\r\n        ScanData(decoder, header, dataView, offset);\r\n\r\n        // Updating texture\r\n        const width = header.dataWindow.xMax - header.dataWindow.xMin + 1;\r\n        const height = header.dataWindow.yMax - header.dataWindow.yMin + 1;\r\n        callback(width, height, texture.generateMipMaps, false, () => {\r\n            const engine = texture.getEngine();\r\n            texture.format = header.format;\r\n            texture.type = decoder.textureType;\r\n            texture.invertY = false;\r\n            texture._gammaSpace = !header.linearSpace;\r\n            if (decoder.byteArray) {\r\n                engine._uploadDataToTextureDirectly(texture, decoder.byteArray, 0, 0, undefined, true);\r\n            }\r\n        });\r\n    }\r\n}\r\n","/* eslint-disable @typescript-eslint/naming-convention */\r\nimport { Logger } from \"core/Misc/logger\";\r\nimport type { DataCursor } from \"./exrLoader.core\";\r\nimport { ParseNullTerminatedString, ParseUint32, ParseValue } from \"./exrLoader.core\";\r\nimport type { IEXRHeader } from \"./exrLoader.interfaces\";\r\n\r\n/**\r\n * Inspired by https://github.com/sciecode/three.js/blob/dev/examples/jsm/loaders/EXRLoader.js\r\n * Referred to the original Industrial Light & Magic OpenEXR implementation and the TinyEXR / Syoyo Fujita\r\n * implementation.\r\n */\r\n\r\n// /*\r\n// Copyright (c) 2014 - 2017, Syoyo Fujita\r\n// All rights reserved.\r\n\r\n// Redistribution and use in source and binary forms, with or without\r\n// modification, are permitted provided that the following conditions are met:\r\n//     * Redistributions of source code must retain the above copyright\r\n//       notice, this list of conditions and the following disclaimer.\r\n//     * Redistributions in binary form must reproduce the above copyright\r\n//       notice, this list of conditions and the following disclaimer in the\r\n//       documentation and/or other materials provided with the distribution.\r\n//     * Neither the name of the Syoyo Fujita nor the\r\n//       names of its contributors may be used to endorse or promote products\r\n//       derived from this software without specific prior written permission.\r\n\r\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\r\n// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\r\n// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\r\n// DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY\r\n// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\r\n// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\r\n// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\r\n// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\r\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\r\n// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\r\n// */\r\n\r\n// // TinyEXR contains some OpenEXR code, which is licensed under ------------\r\n\r\n// ///////////////////////////////////////////////////////////////////////////\r\n// //\r\n// // Copyright (c) 2002, Industrial Light & Magic, a division of Lucas\r\n// // Digital Ltd. LLC\r\n// //\r\n// // All rights reserved.\r\n// //\r\n// // Redistribution and use in source and binary forms, with or without\r\n// // modification, are permitted provided that the following conditions are\r\n// // met:\r\n// // *       Redistributions of source code must retain the above copyright\r\n// // notice, this list of conditions and the following disclaimer.\r\n// // *       Redistributions in binary form must reproduce the above\r\n// // copyright notice, this list of conditions and the following disclaimer\r\n// // in the documentation and/or other materials provided with the\r\n// // distribution.\r\n// // *       Neither the name of Industrial Light & Magic nor the names of\r\n// // its contributors may be used to endorse or promote products derived\r\n// // from this software without specific prior written permission.\r\n// //\r\n// // THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\r\n// // \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\r\n// // LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\r\n// // A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\r\n// // OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\r\n// // SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\r\n// // LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\r\n// // DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\r\n// // THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\r\n// // (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\r\n// // OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\r\n// //\r\n// ///////////////////////////////////////////////////////////////////////////\r\n\r\n// // End of OpenEXR license -------------------------------------------------\r\n\r\nconst EXR_MAGIC = 20000630;\r\n\r\n/**\r\n * Gets the EXR header\r\n * @param dataView defines the data view to read from\r\n * @param offset defines the offset to start reading from\r\n * @returns the header\r\n */\r\nexport function GetExrHeader(dataView: DataView, offset: DataCursor): IEXRHeader {\r\n    if (dataView.getUint32(0, true) != EXR_MAGIC) {\r\n        throw new Error(\"Incorrect OpenEXR format\");\r\n    }\r\n\r\n    const version = dataView.getUint8(4);\r\n\r\n    const specData = dataView.getUint8(5); // fullMask\r\n    const spec = {\r\n        singleTile: !!(specData & 2),\r\n        longName: !!(specData & 4),\r\n        deepFormat: !!(specData & 8),\r\n        multiPart: !!(specData & 16),\r\n    };\r\n\r\n    offset.value = 8;\r\n\r\n    const headerData: any = {};\r\n\r\n    let keepReading = true;\r\n\r\n    while (keepReading) {\r\n        const attributeName = ParseNullTerminatedString(dataView.buffer, offset);\r\n\r\n        if (!attributeName) {\r\n            keepReading = false;\r\n        } else {\r\n            const attributeType = ParseNullTerminatedString(dataView.buffer, offset);\r\n            const attributeSize = ParseUint32(dataView, offset);\r\n            const attributeValue = ParseValue(dataView, offset, attributeType, attributeSize);\r\n\r\n            if (attributeValue === undefined) {\r\n                Logger.Warn(`Unknown header attribute type ${attributeType}'.`);\r\n            } else {\r\n                headerData[attributeName] = attributeValue;\r\n            }\r\n        }\r\n    }\r\n\r\n    if ((specData & ~0x04) != 0) {\r\n        throw new Error(\"Unsupported file format\");\r\n    }\r\n\r\n    return { version: version, spec: spec, ...headerData };\r\n}\r\n","import type { DataCursor } from \"./exrLoader.core\";\r\nimport { CompressionCodes, DecodeFloat32, ParseFloat16, ParseFloat32, ParseInt32, ParseInt64, ParseUint16, ParseUint32 } from \"./exrLoader.core\";\r\nimport { UncompressPIZ, UncompressPXR, UncompressRAW, UncompressRLE, UncompressZIP } from \"./exrLoader.compression\";\r\nimport { FLOAT32_SIZE, INT16_SIZE, type IEXRDecoder, type IEXRHeader } from \"./exrLoader.interfaces\";\r\nimport { Constants } from \"core/Engines/constants\";\r\nimport { Tools } from \"core/Misc/tools\";\r\nimport { ExrLoaderGlobalConfiguration, EXROutputType } from \"./exrLoader.configuration\";\r\n\r\n/**\r\n * Inspired by https://github.com/sciecode/three.js/blob/dev/examples/jsm/loaders/EXRLoader.js\r\n * Referred to the original Industrial Light & Magic OpenEXR implementation and the TinyEXR / Syoyo Fujita\r\n * implementation.\r\n */\r\n\r\n// /*\r\n// Copyright (c) 2014 - 2017, Syoyo Fujita\r\n// All rights reserved.\r\n\r\n// Redistribution and use in source and binary forms, with or without\r\n// modification, are permitted provided that the following conditions are met:\r\n//     * Redistributions of source code must retain the above copyright\r\n//       notice, this list of conditions and the following disclaimer.\r\n//     * Redistributions in binary form must reproduce the above copyright\r\n//       notice, this list of conditions and the following disclaimer in the\r\n//       documentation and/or other materials provided with the distribution.\r\n//     * Neither the name of the Syoyo Fujita nor the\r\n//       names of its contributors may be used to endorse or promote products\r\n//       derived from this software without specific prior written permission.\r\n\r\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\r\n// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\r\n// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\r\n// DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY\r\n// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\r\n// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\r\n// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\r\n// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\r\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\r\n// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\r\n// */\r\n\r\n// // TinyEXR contains some OpenEXR code, which is licensed under ------------\r\n\r\n// ///////////////////////////////////////////////////////////////////////////\r\n// //\r\n// // Copyright (c) 2002, Industrial Light & Magic, a division of Lucas\r\n// // Digital Ltd. LLC\r\n// //\r\n// // All rights reserved.\r\n// //\r\n// // Redistribution and use in source and binary forms, with or without\r\n// // modification, are permitted provided that the following conditions are\r\n// // met:\r\n// // *       Redistributions of source code must retain the above copyright\r\n// // notice, this list of conditions and the following disclaimer.\r\n// // *       Redistributions in binary form must reproduce the above\r\n// // copyright notice, this list of conditions and the following disclaimer\r\n// // in the documentation and/or other materials provided with the\r\n// // distribution.\r\n// // *       Neither the name of Industrial Light & Magic nor the names of\r\n// // its contributors may be used to endorse or promote products derived\r\n// // from this software without specific prior written permission.\r\n// //\r\n// // THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\r\n// // \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\r\n// // LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\r\n// // A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\r\n// // OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\r\n// // SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\r\n// // LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\r\n// // DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\r\n// // THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\r\n// // (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\r\n// // OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\r\n// //\r\n// ///////////////////////////////////////////////////////////////////////////\r\n\r\n// // End of OpenEXR license -------------------------------------------------\r\n\r\n/**\r\n * Create a decoder for the exr file\r\n * @param header header of the exr file\r\n * @param dataView dataview of the exr file\r\n * @param offset current offset\r\n * @param outputType expected output type (float or half float)\r\n * @returns a promise that resolves with the decoder\r\n */\r\nexport async function CreateDecoderAsync(header: IEXRHeader, dataView: DataView, offset: DataCursor, outputType: EXROutputType): Promise<IEXRDecoder> {\r\n    const decoder: IEXRDecoder = {\r\n        size: 0,\r\n        viewer: dataView,\r\n        array: new Uint8Array(dataView.buffer),\r\n        offset: offset,\r\n        width: header.dataWindow.xMax - header.dataWindow.xMin + 1,\r\n        height: header.dataWindow.yMax - header.dataWindow.yMin + 1,\r\n        channels: header.channels.length,\r\n        channelLineOffsets: {},\r\n        scanOrder: () => 0,\r\n        bytesPerLine: 0,\r\n        outLineWidth: 0,\r\n        lines: 0,\r\n        scanlineBlockSize: 0,\r\n        inputSize: null,\r\n        type: 0,\r\n        uncompress: null,\r\n        getter: () => 0,\r\n        format: Constants.TEXTUREFORMAT_RGBA,\r\n        outputChannels: 0,\r\n        decodeChannels: {},\r\n        blockCount: null,\r\n        byteArray: null,\r\n        linearSpace: false,\r\n        textureType: 0,\r\n    };\r\n\r\n    switch (header.compression) {\r\n        case CompressionCodes.NO_COMPRESSION:\r\n            decoder.lines = 1;\r\n            decoder.uncompress = UncompressRAW;\r\n            break;\r\n\r\n        case CompressionCodes.RLE_COMPRESSION:\r\n            decoder.lines = 1;\r\n            decoder.uncompress = UncompressRLE;\r\n            break;\r\n\r\n        case CompressionCodes.ZIPS_COMPRESSION:\r\n            decoder.lines = 1;\r\n            decoder.uncompress = UncompressZIP;\r\n            await Tools.LoadScriptAsync(ExrLoaderGlobalConfiguration.FFLATEUrl);\r\n            break;\r\n\r\n        case CompressionCodes.ZIP_COMPRESSION:\r\n            decoder.lines = 16;\r\n            decoder.uncompress = UncompressZIP;\r\n            await Tools.LoadScriptAsync(ExrLoaderGlobalConfiguration.FFLATEUrl);\r\n            break;\r\n\r\n        case CompressionCodes.PIZ_COMPRESSION:\r\n            decoder.lines = 32;\r\n            decoder.uncompress = UncompressPIZ;\r\n            break;\r\n\r\n        case CompressionCodes.PXR24_COMPRESSION:\r\n            decoder.lines = 16;\r\n            decoder.uncompress = UncompressPXR;\r\n            await Tools.LoadScriptAsync(ExrLoaderGlobalConfiguration.FFLATEUrl);\r\n            break;\r\n\r\n        default:\r\n            throw new Error(CompressionCodes[header.compression] + \" is unsupported\");\r\n    }\r\n\r\n    decoder.scanlineBlockSize = decoder.lines;\r\n\r\n    const channels: {\r\n        [key: string]: boolean;\r\n    } = {};\r\n    for (const channel of header.channels) {\r\n        switch (channel.name) {\r\n            case \"Y\":\r\n            case \"R\":\r\n            case \"G\":\r\n            case \"B\":\r\n            case \"A\":\r\n                channels[channel.name] = true;\r\n                decoder.type = channel.pixelType;\r\n        }\r\n    }\r\n\r\n    // RGB images will be converted to RGBA format, preventing software emulation in select devices.\r\n    let fillAlpha = false;\r\n\r\n    if (channels.R && channels.G && channels.B) {\r\n        fillAlpha = !channels.A;\r\n        decoder.outputChannels = 4;\r\n        decoder.decodeChannels = { R: 0, G: 1, B: 2, A: 3 };\r\n    } else if (channels.Y) {\r\n        decoder.outputChannels = 1;\r\n        decoder.decodeChannels = { Y: 0 };\r\n    } else {\r\n        throw new Error(\"EXRLoader.parse: file contains unsupported data channels.\");\r\n    }\r\n\r\n    if (decoder.type === 1) {\r\n        // half\r\n        switch (outputType) {\r\n            case EXROutputType.Float:\r\n                decoder.getter = ParseFloat16;\r\n                decoder.inputSize = INT16_SIZE;\r\n                break;\r\n\r\n            case EXROutputType.HalfFloat:\r\n                decoder.getter = ParseUint16;\r\n                decoder.inputSize = INT16_SIZE;\r\n                break;\r\n        }\r\n    } else if (decoder.type === 2) {\r\n        // float\r\n        switch (outputType) {\r\n            case EXROutputType.Float:\r\n                decoder.getter = ParseFloat32;\r\n                decoder.inputSize = FLOAT32_SIZE;\r\n                break;\r\n\r\n            case EXROutputType.HalfFloat:\r\n                decoder.getter = DecodeFloat32;\r\n                decoder.inputSize = FLOAT32_SIZE;\r\n        }\r\n    } else {\r\n        throw new Error(\"Unsupported pixelType \" + decoder.type + \" for \" + header.compression);\r\n    }\r\n\r\n    decoder.blockCount = decoder.height / decoder.scanlineBlockSize;\r\n\r\n    for (let i = 0; i < decoder.blockCount; i++) {\r\n        ParseInt64(dataView, offset); // scanlineOffset\r\n    }\r\n\r\n    // we should be passed the scanline offset table, ready to start reading pixel data.\r\n    const size = decoder.width * decoder.height * decoder.outputChannels;\r\n\r\n    switch (outputType) {\r\n        case EXROutputType.Float:\r\n            decoder.byteArray = new Float32Array(size);\r\n            decoder.textureType = Constants.TEXTURETYPE_FLOAT;\r\n\r\n            // Fill initially with 1s for the alpha value if the texture is not RGBA, RGB values will be overwritten\r\n            if (fillAlpha) {\r\n                decoder.byteArray.fill(1, 0, size);\r\n            }\r\n\r\n            break;\r\n\r\n        case EXROutputType.HalfFloat:\r\n            decoder.byteArray = new Uint16Array(size);\r\n            decoder.textureType = Constants.TEXTURETYPE_HALF_FLOAT;\r\n\r\n            if (fillAlpha) {\r\n                decoder.byteArray.fill(0x3c00, 0, size); // Uint16Array holds half float data, 0x3C00 is 1\r\n            }\r\n\r\n            break;\r\n\r\n        default:\r\n            throw new Error(\"Unsupported type: \" + outputType);\r\n    }\r\n\r\n    let byteOffset = 0;\r\n    for (const channel of header.channels) {\r\n        if (decoder.decodeChannels[channel.name] !== undefined) {\r\n            decoder.channelLineOffsets[channel.name] = byteOffset * decoder.width;\r\n        }\r\n\r\n        byteOffset += channel.pixelType * 2;\r\n    }\r\n\r\n    decoder.bytesPerLine = decoder.width * byteOffset;\r\n    decoder.outLineWidth = decoder.width * decoder.outputChannels;\r\n\r\n    if (header.lineOrder === \"INCREASING_Y\") {\r\n        decoder.scanOrder = (y) => y;\r\n    } else {\r\n        decoder.scanOrder = (y) => decoder.height - 1 - y;\r\n    }\r\n\r\n    if (decoder.outputChannels == 4) {\r\n        decoder.format = Constants.TEXTUREFORMAT_RGBA;\r\n        decoder.linearSpace = true;\r\n    } else {\r\n        decoder.format = Constants.TEXTUREFORMAT_R;\r\n        decoder.linearSpace = false;\r\n    }\r\n\r\n    return decoder;\r\n}\r\n\r\n/**\r\n * Scan the data of the exr file\r\n * @param decoder decoder to use\r\n * @param header header of the exr file\r\n * @param dataView dataview of the exr file\r\n * @param offset current offset\r\n */\r\nexport function ScanData(decoder: IEXRDecoder, header: IEXRHeader, dataView: DataView, offset: DataCursor): void {\r\n    const tmpOffset = { value: 0 };\r\n\r\n    for (let scanlineBlockIdx = 0; scanlineBlockIdx < decoder.height / decoder.scanlineBlockSize; scanlineBlockIdx++) {\r\n        const line = ParseInt32(dataView, offset) - header.dataWindow.yMin; // line_no\r\n        decoder.size = ParseUint32(dataView, offset); // data_len\r\n        decoder.lines = line + decoder.scanlineBlockSize > decoder.height ? decoder.height - line : decoder.scanlineBlockSize;\r\n\r\n        const isCompressed = decoder.size < decoder.lines * decoder.bytesPerLine;\r\n        const viewer = isCompressed && decoder.uncompress ? decoder.uncompress(decoder) : UncompressRAW(decoder);\r\n\r\n        offset.value += decoder.size;\r\n\r\n        for (let line_y = 0; line_y < decoder.scanlineBlockSize; line_y++) {\r\n            const scan_y = scanlineBlockIdx * decoder.scanlineBlockSize;\r\n            const true_y = line_y + decoder.scanOrder(scan_y);\r\n            if (true_y >= decoder.height) {\r\n                continue;\r\n            }\r\n\r\n            const lineOffset = line_y * decoder.bytesPerLine;\r\n            const outLineOffset = (decoder.height - 1 - true_y) * decoder.outLineWidth;\r\n\r\n            for (let channelID = 0; channelID < decoder.channels; channelID++) {\r\n                const name = header.channels[channelID].name;\r\n                const lOff = decoder.channelLineOffsets[name];\r\n                const cOff = decoder.decodeChannels[name];\r\n\r\n                if (cOff === undefined) {\r\n                    continue;\r\n                }\r\n\r\n                tmpOffset.value = lineOffset + lOff;\r\n\r\n                for (let x = 0; x < decoder.width; x++) {\r\n                    const outIndex = outLineOffset + x * decoder.outputChannels + cOff;\r\n                    if (decoder.byteArray) {\r\n                        decoder.byteArray[outIndex] = decoder.getter(viewer, tmpOffset);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n"],"names":["INT32_SIZE","FLOAT32_SIZE","INT8_SIZE","INT16_SIZE","ULONG_SIZE","USHORT_RANGE","BITMAP_SIZE","HUF_DECBITS","HUF_ENCSIZE","HUF_DECSIZE","HUF_DECMASK","SHORT_ZEROCODE_RUN","LONG_ZEROCODE_RUN","SHORTEST_LONG_RUN","CompressionCodes","LineOrders","_tables","buffer","ArrayBuffer","floatView","Float32Array","uint32View","Uint32Array","baseTable","shiftTable","i","e","mantissaTable","exponentTable","offsetTable","m","_GenerateTables","ParseNullTerminatedString","offset","uintBuffer","Uint8Array","endOffset","value","stringValue","TextDecoder","decode","slice","ParseInt32","dataView","getInt32","ParseUint32","getUint32","ParseUint8","getUint8","ParseUint16","getUint16","ParseUint8Array","array","ParseInt64","int","DataView","prototype","Number","getBigInt64","ParseFloat32","getFloat32","ParseFloat16","binary","exponent","fraction","NaN","Infinity","Math","pow","DecodeFloat16","DecodeFloat32","abs","Error","Clamp","f","ToHalfFloat","ParseValue","type","size","ParseFixedLengthString","startOffset","channels","name","pixelType","pLinear","xSampling","ySampling","push","ParseChlist","redX","redY","greenX","greenY","blueX","blueY","whiteX","whiteY","ParseChromaticities","ParseCompression","xMin","yMin","xMax","yMax","ParseBox2i","lineOrder","ParseLineOrder","ParseV2f","ParseV3f","ParseRational","ParseTimecode","Predictor","source","t","length","d","InterleaveScalar","out","t1","t2","floor","s","stop","A_OFFSET","MOD_MASK","GetBits","nBits","c","lc","l","GetChar","GetCode","po","rlc","outBuffer","outBufferOffset","outBufferEndOffset","gc","cs","HufTableBuffer","Array","HufUnpackEncTable","ni","im","iM","hcode","p","gb","zerun","nc","HufCanonicalCodeTable","HufLength","code","HufCode","HufUncompress","nCompressed","nRaw","initialInOffset","freq","hdec","len","lit","HufClearDecTable","hdecod","pl","plOffset","HufBuildDecTable","encodingTable","decodingTable","no","outOffset","inOffsetEnd","trunc","gCode","j","HufDecode","UInt16","Int16","ref","Wdec14","h","ls","hs","ai","a","b","Wdec16","bb","Wav2Decode","nx","ox","ny","oy","mx","w14","n","p2","py","ey","oy1","oy2","ox1","ox2","i00","i01","i10","i11","px","ex","p01","p10","p11","result","UncompressRAW","decoder","UncompressRLE","compressed","viewer","rawBuffer","byteLength","reader","getInt8","count","DecodeRunLength","tmpBuffer","UncompressZIP","fflate","unzlibSync","UncompressPXR","sz","lines","width","Uint16Array","tmpBufferEnd","writePtr","ptr","y","pixel","UncompressPIZ","inDataView","inOffset","scanlineBlockSize","bitmap","outBufferEnd","pizChannelData","minNonZero","maxNonZero","lut","maxValue","k","ReverseLutFromBitmap","cd","start","data","nData","ApplyLut","tmpOffset","cp","end","set","EXROutputType","ExrLoaderGlobalConfiguration","DefaultOutputType","HalfFloat","FFLATEUrl","_ExrTextureLoader","constructor","supportCascades","loadCubeData","_data","_texture","_createPolynomials","_onLoad","_onError","loadData","texture","callback","header","version","specData","spec","singleTile","longName","deepFormat","multiPart","headerData","keepReading","attributeName","attributeType","attributeValue","undefined","Logger","Warn","GetExrHeader","async","outputType","dataWindow","height","channelLineOffsets","scanOrder","bytesPerLine","outLineWidth","inputSize","uncompress","getter","format","outputChannels","decodeChannels","blockCount","byteArray","linearSpace","textureType","compression","NO_COMPRESSION","RLE_COMPRESSION","ZIPS_COMPRESSION","Tools","LoadScriptAsync","ZIP_COMPRESSION","PIZ_COMPRESSION","PXR24_COMPRESSION","channel","fillAlpha","R","G","B","A","Y","Float","fill","byteOffset","CreateDecoderAsync","scanlineBlockIdx","line","line_y","scan_y","true_y","lineOffset","outLineOffset","channelID","lOff","cOff","x","outIndex","ScanData","generateMipMaps","engine","getEngine","invertY","_gammaSpace","_uploadDataToTextureDirectly"],"sourceRoot":""}